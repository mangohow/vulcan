package dbgenerator

import (
	"bytes"
	"fmt"
	"github.com/mangohow/mangokit/tools/collection"
	"github.com/mangohow/mangokit/tools/stream"
	"github.com/mangohow/vulcan"
	"github.com/mangohow/vulcan/internal/ast/astutils"
	"github.com/mangohow/vulcan/internal/ast/parser/types"
	"github.com/mangohow/vulcan/internal/utils"
	"github.com/mangohow/vulcan/internal/utils/sqlutils"
	"github.com/mangohow/vulcan/internal/version"
	"go/ast"
	"go/format"
	"go/token"
	"os"
	"reflect"
	"strings"
)

var (
	fileHeaderComment = fmt.Sprintf("// Code generated by vulcan. DO NOT EDIT.\n// version: vulcan %s\n\n", version.Version)
)

const (
	corePackageName = "vulcan"
)

var (
	execOptionName              string
	execOptionFieldSqlStmtName  string
	execOptionFieldArgsName     string
	execOptionFieldExecerName   string
	execOptionFieldFirstArgName string

	invokePreHandlerName  = "InvokePreHandler"
	invokePostHandlerName = "InvokePostHandler"
	newResultOptionName   = "NewResultOption"

	dbSelectOptName = "Select"
	dbGetOptName    = "Get"
	dbExecOptName   = "Exec"

	sqlTypeInsertName = "SQLTypeInsert"
	sqlTypeUpdateName = "SQLTypeUpdate"
	sqlTypeDeleteName = "SQLTypeDelete"
	sqlTypeSelectName = "SQLTypeSelect"

	nilName = "nil"
	errName = "err"

	entityFiledPrimaryKeyName = "pk"

	lastInsertIdFuncName = "LastInsertId"
	rowsAffectedFuncName = "RowsAffected"

	sqlxPackageName     = "sqlx"
	sqlxPackagePathName = "github.com/jmoiron/sqlx"
	sqlxDBName          = "DB"
)

func initExecOptionNames() {
	rt := reflect.TypeOf(vulcan.ExecOption{})
	n := rt.NumField()
	for i := 0; i < n; i++ {
		field := rt.Field(i)
		tag := field.Tag.Get("name")
		switch tag {
		case "sql":
			execOptionFieldSqlStmtName = field.Name
		case "args":
			execOptionFieldArgsName = field.Name
		case "execer":
			execOptionFieldExecerName = field.Name
		case "firstArg":
			execOptionFieldFirstArgName = field.Name
		}
	}
}
func init() {
	initExecOptionNames()
}

type FileGenerator struct {
	srcFile  *types.File
	optsName string
}

func NewFileGenerator(file *types.File) *FileGenerator {
	return &FileGenerator{
		srcFile: file,
	}
}

func (g *FileGenerator) Execute(filename string) error {
	for _, d := range g.srcFile.Declarations {
		if d.SqlFuncDecl == nil {
			continue
		}

		if err := g.generateAst(&d); err != nil {
			return err
		}
	}

	return g.generateCode(filename)
}

func (g *FileGenerator) generateAst(decl *types.Declaration) error {
	// 添加opt参数
	fnDecl, ok := decl.AstDecl.(*ast.FuncDecl)
	if !ok {
		return fmt.Errorf("convert type error")
	}
	optsMame := g.getOptsName("opts", decl.SqlFuncDecl.InputParam)
	g.optsName = optsMame
	ellipsis := astutils.BuildEllipsisField(optsMame, "vulcan.Option")
	fnDecl.Type.Params.List = append(fnDecl.Type.Params.List, ellipsis)

	// 生成函数体
	body, err := g.generateFuncBodyAst(decl)
	if err != nil {
		return fmt.Errorf("generate func body error, %v", err)
	}
	fnDecl.Body = body
	decl.AstDecl = fnDecl

	return nil
}

func (g *FileGenerator) generateFuncBodyAst(decl *types.Declaration) (*ast.BlockStmt, error) {
	sql := decl.SqlFuncDecl.Sql[0]
	switch sql.(type) {
	case types.RawSQL:
		// 处理静态sql
		rawSQL := sql.(types.RawSQL)
		return g.generateStaticSqlFuncBodyAst(decl, rawSQL.Stmt())
	default:
		// 处理静态sql
		return g.generateDynamicSqlFuncBodyAst(decl)
	}
}

func (g *FileGenerator) generateStaticSqlFuncBodyAst(decl *types.Declaration, sql string) (*ast.BlockStmt, error) {
	options, err := preprocessingStaticSqlGen(decl, sql)
	if err != nil {
		return nil, err
	}
	body := &ast.BlockStmt{}

	// 生成option.ExecOption赋值操作
	composite := &ast.CompositeLit{
		Lbrace: token.Pos(1),
		Rbrace: token.Pos(2),
		Type:   astutils.BuildIdentOrSelectorExpr(corePackageName + "." + "ExecOption"),
		Elts: []ast.Expr{
			astutils.BuildKeyValueBasicLitExpr(execOptionFieldSqlStmtName, fmt.Sprintf("%q", options.SQL), token.STRING, 2000),
			astutils.BuildKeyValueExpr(execOptionFieldExecerName, astutils.BuildIdentOrSelectorExpr(options.receiverName+"."+options.receiverDbFieldName), 3000),
		},
	}

	// TODO 如果第一个参数为Page则需要传入ExecOption

	// 如果sql参数不为空, 则添加参数
	if len(options.ParamsName) > 0 {
		composite.Elts = append(composite.Elts, astutils.BuildKeyValueExpr("Args", &ast.CompositeLit{
			Type: &ast.ArrayType{
				Elt: ast.NewIdent("any"),
			},
			Elts: stream.Map(options.ParamsName, func(name string) ast.Expr {
				return astutils.BuildIdentOrSelectorExpr(name)
			}),
		}, 4000))
	}

	optionAssign := &ast.AssignStmt{
		Lhs: []ast.Expr{ast.NewIdent(options.execOptionName)},
		Rhs: []ast.Expr{astutils.BuildUnaryExpr("&", composite)},
		Tok: token.DEFINE,
	}
	body.List = append(body.List, optionAssign)

	// 构建拦截器preHandle调用语句
	preInterceptorCall := astutils.BuildSimpleCallAssign(corePackageName+"."+invokePreHandlerName, []*astutils.FuncArg{
		{Name: options.execOptionName},
		{Name: g.optsName},
	}, true)
	body.List = append(body.List, &ast.ExprStmt{X: preInterceptorCall})

	if decl.SqlFuncDecl.Annotation == types.SQLSelectFunc {
		// 如果是select语句, 则需要new一个对象
		assignStmt := astutils.BuildInitAssignExpr(decl.SqlFuncDecl.FuncReturnResultParam, options.sqlOperationResultName, decl.PkgInfo.PackageName)
		body.List = append(body.List, assignStmt)
	}

	// 构建数据库操作语句
	execArgs := make([]*astutils.FuncArg, 0, 3)
	if decl.SqlFuncDecl.Annotation == types.SQLSelectFunc {
		andFlag := false
		if t := decl.SqlFuncDecl.FuncReturnResultParam.Type; t.IsSlice() || !t.IsPointer() {
			andFlag = true
		}
		execArgs = append(execArgs, &astutils.FuncArg{Name: options.sqlOperationResultName, AndFlag: andFlag})
	}
	execArgs = append(execArgs, stream.Map(options.sqlExecuteArgsName, func(v string) *astutils.FuncArg {
		return &astutils.FuncArg{Name: v}
	})...)
	dbCallExpr := astutils.BuildDefineStmtByExpr(astutils.BuildIdentList(options.sqlExecuteResultName...),
		[]ast.Expr{astutils.BuildSimpleCallAssign(options.execOptionName+"."+options.sqlOperationName, execArgs, true)})
	body.List = append(body.List, dbCallExpr)

	// 构建拦截器postHandle调用语句
	postInterceptorCall := astutils.BuildCallExpr(astutils.BuildIdentOrSelectorExpr(corePackageName+"."+invokePostHandlerName), []ast.Expr{
		astutils.BuildSimpleCallAssign(corePackageName+"."+newResultOptionName, stream.Map(options.newResultOptionArgsName, func(v string) *astutils.FuncArg {
			return &astutils.FuncArg{Name: v}
		}), false),
	}, false)
	body.List = append(body.List, &ast.ExprStmt{X: postInterceptorCall})

	// 构建err判断语句
	body.List = append(body.List, g.generateReturnErrAst(decl.SqlFuncDecl.FuncReturnResultParam, options.sqlExecuteResultName[0], decl.SqlFuncDecl.Annotation))

	// 如果是插入语句, 可能需要给自增Id赋值
	if decl.SqlFuncDecl.Annotation == types.SQLInsertFunc {
		stmts := g.generatePrimaryKeyAssign(options, decl)
		if len(stmts) > 0 {
			// 添加空行
			body.List = append(body.List, astutils.BuildEmptyStmt())
			body.List = append(body.List, stmts...)
		}
	}

	if decl.SqlFuncDecl.FuncReturnResultParam != nil {
		// 如果是增删改语句, 可能需要返回rowAffected
		rowsAffectedStmt := g.generateRowAffectedAssignAndReturnStmt(options, decl)
		body.List = append(body.List, astutils.BuildEmptyStmt())
		body.List = append(body.List, rowsAffectedStmt...)
	} else {
		// 直接构建返回语句
		body.List = append(body.List, astutils.BuildReturnStmt("nil"))
	}

	return body, nil
}

// 构建if err != nil {}
// return语句: return 0, err
// return nil, err
// return false, err
// return res, err
func (g *FileGenerator) generateReturnErrAst(param *types.Param, sqlExecuteResultName, sqlType string) *ast.IfStmt {
	if param == nil {
		return astutils.BuildIfErrNENilReturn("err")
	}

	if param.Type.IsPointer() || param.Type.IsSlice() {
		return astutils.BuildIfErrNENilReturn("nil", "err")
	}

	returnArgs := make([]interface{}, 0, 2)
	switch sqlType {
	case types.SQLInsertFunc, types.SQLDeleteFunc, types.SQLUpdateFunc:
		switch param.Type.Kind {
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
			reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
			returnArgs = append(returnArgs, 0, "err")
		case reflect.Bool:
			returnArgs = append(returnArgs, false, "err")
		case reflect.String:
			returnArgs = append(returnArgs, `""`, "err")
		case reflect.Float32, reflect.Float64:
			returnArgs = append(returnArgs, 0.0, "err")
		}
	case types.SQLSelectFunc:
		returnArgs = append(returnArgs, sqlExecuteResultName, "err")
	}

	return astutils.BuildIfErrNENilReturn(returnArgs...)
}

// 构建给主键赋值的语句
// lastInsertedId, err := result.LastInsertId()
//
//	if err != nil {
//	    return 0, err
//	}
//
// user.Id = lastInsertedId
func (g *FileGenerator) generatePrimaryKeyAssign(options *staticSqlGenOptions, decl *types.Declaration) []ast.Stmt {
	var (
		findPrimaryKey func(param *types.Param) *types.Param
		names          []string
	)
	findPrimaryKey = func(param *types.Param) *types.Param {
		if param == nil {
			return nil
		}
		if param.Type.IsSlice() {
			return nil
		}
		if param.Type.IsPointer() {
			return findPrimaryKey(&types.Param{Name: param.Name, Type: *param.Type.ValueType})
		}

		if param.Type.IsBasicType() {
			if tag := param.Type.Tag.Get("db"); tag != "" && strings.Contains(tag, entityFiledPrimaryKeyName) {
				return param
			}
		}

		names = append(names, param.Name)
		for _, field := range param.Type.Fields {
			pkType := findPrimaryKey(field)
			if pkType != nil {
				names = append(names, field.Name)
				return pkType
			}
		}

		return nil
	}

	var (
		pkParam *types.Param
	)
	inputParams := utils.Values(decl.SqlFuncDecl.InputParam)
	for i := 0; i < len(inputParams); {
		pkParam = findPrimaryKey(inputParams[i])
		if pkParam != nil {
			break
		}
	}

	if pkParam == nil {
		return nil
	}

	switch pkParam.Type.Kind {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
	default:
		return nil
	}

	// 构建 lastInsertedId, err := result.LastInsertId()
	assignStmt := astutils.BuildCallAssign([]string{options.lastInsertedIdName, "err"}, ":=", options.sqlExecuteResultName[0]+"."+lastInsertIdFuncName, nil, false)
	// 构建if err != nil {return err}
	errReturnStmt := g.generateReturnErrAst(decl.SqlFuncDecl.FuncReturnResultParam, options.sqlExecuteResultName[0], decl.SqlFuncDecl.Annotation)
	// 构建主键赋值
	var idAssignStmt ast.Stmt
	if pkParam.Type.Kind == reflect.Int64 {
		idAssignStmt = astutils.BuildAssignStmt([]string{strings.Join(names, ".")}, []string{options.lastInsertedIdName})
	} else {
		idAssignStmt = astutils.BuildCallAssign([]string{strings.Join(names, ".")}, "=", pkParam.Type.Kind.String(), []*astutils.FuncArg{
			{Name: options.lastInsertedIdName},
		}, false)
	}

	return []ast.Stmt{assignStmt, errReturnStmt, astutils.BuildEmptyStmt(), idAssignStmt}
}

func (g *FileGenerator) generateRowAffectedAssignAndReturnStmt(options *staticSqlGenOptions, decl *types.Declaration) []ast.Stmt {
	if decl.SqlFuncDecl.Annotation == types.SQLSelectFunc || decl.SqlFuncDecl.FuncReturnResultParam == nil {
		return []ast.Stmt{astutils.BuildReturnStmt(options.sqlOperationResultName, "nil")}
	}

	assignStmt := astutils.BuildCallAssign([]string{options.rowsAffectedName, "err"}, ":=", options.sqlExecuteResultName[0]+"."+rowsAffectedFuncName, nil, false)
	errReturnStmt := g.generateReturnErrAst(decl.SqlFuncDecl.FuncReturnResultParam, options.sqlExecuteResultName[0], decl.SqlFuncDecl.Annotation)
	var returnStmt ast.Stmt
	if decl.SqlFuncDecl.FuncReturnResultParam.Type.Kind == reflect.Int64 {
		returnStmt = astutils.BuildReturnStmt(options.rowsAffectedName, "nil")
	} else {
		returnStmt = astutils.BuildReturnStmtByExpr(astutils.BuildCallExpr(ast.NewIdent(decl.SqlFuncDecl.FuncReturnResultParam.Type.Kind.String()), []ast.Expr{ast.NewIdent(options.rowsAffectedName)}, false), ast.NewIdent("nil"))
	}

	return []ast.Stmt{assignStmt, errReturnStmt, astutils.BuildEmptyStmt(), returnStmt}
}

type staticSqlGenOptions struct {
	*sqlutils.SqlParseResult
	execOptionName          string
	receiverName            string
	receiverDbFieldName     string
	sqlOperationName        string
	sqlOperationResultName  string
	sqlExecuteResultName    []string
	sqlExecuteArgsName      []string
	lastInsertedIdName      string
	rowsAffectedName        string
	newResultOptionArgsName []string
}

// 对静态sql的代码生成进行预处理
func preprocessingStaticSqlGen(decl *types.Declaration, sql string) (*staticSqlGenOptions, error) {
	usedNames := collection.NewSetFromSlice[string](utils.Keys(decl.SqlFuncDecl.InputParam))
	if decl.SqlFuncDecl.Receiver != nil {
		usedNames.Add(decl.SqlFuncDecl.Receiver.Name)
	}
	for _, v := range decl.SqlFuncDecl.OutputParam {
		if v.Name != "" {
			usedNames.Add(v.Name)
		}
	}

	// 对sql进行解析, 解析出参数列表, 并替换为?
	sqlInfo := sqlutils.ParseSQLStmt(sql)

	var (
		sqlOperationName     = dbExecOptName
		sqlExecuteResultName = []string{getAvailableName("result", usedNames), "err"}
		options              = &staticSqlGenOptions{
			execOptionName:         getAvailableName("option", usedNames),
			receiverName:           decl.SqlFuncDecl.Receiver.Name,
			receiverDbFieldName:    getReceiverDbFieldName(decl.SqlFuncDecl.Receiver),
			SqlParseResult:         sqlInfo,
			sqlOperationResultName: getAvailableName("res", usedNames),
			lastInsertedIdName:     getAvailableName("lasInsertedId", usedNames),
			rowsAffectedName:       getAvailableName("rowsAffected", usedNames),
		}
	)

	options.sqlExecuteArgsName = append(options.sqlExecuteArgsName, options.execOptionName+"."+execOptionFieldSqlStmtName, options.execOptionName+"."+execOptionFieldArgsName)
	switch decl.SqlFuncDecl.Annotation {
	case types.SQLInsertFunc:
		options.newResultOptionArgsName = append(options.newResultOptionArgsName, corePackageName+"."+sqlTypeInsertName, nilName, errName, sqlExecuteResultName[0])
	case types.SQLDeleteFunc:
		options.newResultOptionArgsName = append(options.newResultOptionArgsName, corePackageName+"."+sqlTypeDeleteName, nilName, errName, sqlExecuteResultName[0])
	case types.SQLUpdateFunc:
		options.newResultOptionArgsName = append(options.newResultOptionArgsName, corePackageName+"."+sqlTypeUpdateName, nilName, errName, sqlExecuteResultName[0])
	case types.SQLSelectFunc:
		sqlOperationName = dbGetOptName
		if decl.SqlFuncDecl.FuncReturnResultParam.Type.IsSlice() {
			sqlOperationName = dbSelectOptName
		}
		sqlExecuteResultName = sqlExecuteResultName[1:]
		options.newResultOptionArgsName = append(options.newResultOptionArgsName, corePackageName+"."+sqlTypeSelectName, options.sqlOperationResultName, errName, nilName)
	default:
		return nil, fmt.Errorf("annotation error")
	}

	options.sqlOperationName = sqlOperationName
	options.sqlExecuteResultName = sqlExecuteResultName

	return options, nil
}

// 防止函数body中出现的变量名和函数参数名称出现重复
func getAvailableName(initial string, usedNames collection.Set[string]) string {
	if !usedNames.Has(initial) {
		usedNames.Add(initial)
		return initial
	}

	initial += "x"

	return getAvailableName(initial, usedNames)
}

func getReceiverDbFieldName(param *types.Param) string {
	if param.Type.IsPointer() {
		return getReceiverDbFieldName(&types.Param{Name: param.Name, Type: *param.Type.ValueType})
	}

	for _, field := range param.Type.Fields {
		typeSpec := &field.Type
		if field.Type.IsPointer() {
			typeSpec = field.Type.ValueType
		}
		if typeSpec.Name == sqlxDBName && typeSpec.Package.PackageName == sqlxPackageName && typeSpec.Package.PackagePath == sqlxPackagePathName {
			return field.Name
		}
	}

	return ""
}

func (g *FileGenerator) generateDynamicSqlFuncBodyAst(decl *types.Declaration) (*ast.BlockStmt, error) {

	return nil, nil
}

func (g *FileGenerator) getOptsName(optsName string, inputParm map[string]*types.Param) string {
	for _, v := range inputParm {
		if v.Name == optsName {
			optsName += "1"
			optsName = g.getOptsName(optsName, inputParm)
			break
		}
	}

	return optsName
}

func (g *FileGenerator) generateCode(filename string) error {
	astFile := &ast.File{
		Name:    g.srcFile.AstFile.Name,
		Imports: g.srcFile.PkgInfo.AstImports,
	}
	importGenDecl := &ast.GenDecl{
		Tok: token.IMPORT,
	}
	for _, importSpec := range g.srcFile.PkgInfo.AstImports {
		importGenDecl.Specs = append(importGenDecl.Specs, importSpec)
	}
	astFile.Decls = append(astFile.Decls, importGenDecl)
	astFile.Decls = append(astFile.Decls, stream.Map(g.srcFile.Declarations, func(t types.Declaration) ast.Decl {
		return t.AstDecl
	})...)

	buffer := bytes.NewBuffer(nil)
	err := format.Node(buffer, token.NewFileSet(), astFile)
	if err != nil {
		return fmt.Errorf("generate source code error: %v", err)
	}

	source := buffer.String()
	// 替换空行
	source = trimEmptyLineSign(source)

	// 在所有函数声明前面加一个空行
	source = strings.ReplaceAll(source, "\nfunc", "\n\nfunc")

	// 所有的结构体初始化, key:val添加换行
	const startKey = "vulcan.ExecOption{SqlStmt"
	const endKey = "}}\n"
	replacer := strings.NewReplacer([]string{
		startKey, "vulcan.ExecOption{\n\t\tSqlStmt",
		", Execer:", ",\n\t\tExecer:",
		", Args:", ",\n\t\tArgs:",
		endKey, "},\n\t}\n",
	}...)
	for {
		idx1 := strings.Index(source, startKey)
		if idx1 == -1 {
			break
		}
		idx2 := strings.Index(source[idx1:], endKey)
		fragment := source[idx1 : idx1+idx2+len(endKey)]
		fragment = replacer.Replace(fragment)
		source = source[:idx1] + fragment + source[idx1+idx2+len(endKey):]
	}

	file, err := os.OpenFile(filename, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0644)
	if err != nil {
		return fmt.Errorf("open file error: %v", err)
	}
	defer file.Close()

	fmt.Fprint(file, fileHeaderComment)
	fmt.Fprint(file, source)
	return nil
}

func trimEmptyLineSign(source string) string {
	return strings.ReplaceAll(source, astutils.EmptyLineSign, "")
}
