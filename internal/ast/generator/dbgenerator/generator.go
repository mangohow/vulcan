package dbgenerator

import (
	"fmt"
	"github.com/mangohow/vulcan"
	"github.com/mangohow/vulcan/internal/ast/astutils"
	"github.com/mangohow/vulcan/internal/ast/parser/types"
	"github.com/mangohow/vulcan/internal/version"
	"go/ast"
	"go/token"
	"reflect"
	"strings"
)

var (
	fileHeaderComment = fmt.Sprintf("// Code generated by vulcan. DO NOT EDIT.\n// version: vulcan %s", version.Version)
)

const (
	corePackageName = "vulcan"
)

var (
	execOptionName              string
	execOptionFieldSqlStmtName  string
	execOptionFieldArgsName     string
	execOptionFieldExecerName   string
	execOptionFieldFirstArgName string

	invokeExecInterceptorName = "InvokeExecInterceptor"

	dbSelectOptName = "Select"
	dbExecOptName   = "Exec"
)

func initExecOptionNames() {
	rt := reflect.TypeOf(vulcan.ExecOption{})
	n := rt.NumField()
	for i := 0; i < n; i++ {
		field := rt.Field(i)
		tag := field.Tag.Get("name")
		switch tag {
		case "sql":
			execOptionFieldSqlStmtName = field.Name
		case "args":
			execOptionFieldArgsName = field.Name
		case "execer":
			execOptionFieldExecerName = field.Name
		case "firstArg":
			execOptionFieldFirstArgName = field.Name
		}
	}
}
func init() {
	initExecOptionNames()
}

type FileGenerator struct {
	insertImports []string
	srcFile       *types.File
	optsName      string
}

func NewFileGenerator(file *types.File) *FileGenerator {
	return &FileGenerator{
		insertImports: []string{
			"github.com/mangohow/vulcan/db",
		},
		srcFile: file,
	}
}

func (g *FileGenerator) Execute() error {
	for _, d := range g.srcFile.Declarations {
		if d.SqlFuncDecl == nil {
			continue
		}

		if err := g.generateAst(&d); err != nil {
			return err
		}

		if err := g.generateCode(); err != nil {
			return err
		}
	}

	return g.generateCode()
}

func (g *FileGenerator) generateAst(decl *types.Declaration) error {
	// 添加opt参数
	fnDecl, ok := decl.AstDecl.(*ast.FuncDecl)
	if !ok {
		return fmt.Errorf("convert type error")
	}
	optsMame := g.getOptsName("opts", decl.SqlFuncDecl.InputParam)
	g.optsName = optsMame
	ellipsis := astutils.BuildEllipsisField(optsMame, "db.ExecOption")
	fnDecl.Type.Params.List = append(fnDecl.Type.Params.List, ellipsis)

	// 生成函数体
	body, err := g.generateFuncBodyAst(decl)
	if err != nil {
		return fmt.Errorf("generate func body error, %v", err)
	}
	fnDecl.Body = body
	decl.AstDecl = fnDecl

	return nil
}

func (g *FileGenerator) generateFuncBodyAst(decl *types.Declaration) (*ast.BlockStmt, error) {
	sql := decl.SqlFuncDecl.Sql[0]
	switch sql.(type) {
	case types.RawSQL:
		// 处理静态sql
		rawSQL := sql.(types.RawSQL)
		return g.generateStaticSqlFuncBodyAst(decl, rawSQL.Stmt())
	default:
		// 处理静态sql
		return g.generateDynamicSqlFuncBodyAst(decl)
	}
}

func (g *FileGenerator) generateStaticSqlFuncBodyAst(decl *types.Declaration, sql string) (*ast.BlockStmt, error) {
	var (
		execOptName         = getExecOptionName("option", decl.SqlFuncDecl.InputParam, decl.SqlFuncDecl.OutputParam)
		receiverName        = decl.SqlFuncDecl.Receiver.Name
		receiverDbFieldName = getReceiverDbFieldName(decl.SqlFuncDecl.Receiver)
	)

	fnDecl, _ := decl.AstDecl.(*ast.FuncDecl)

	// 生成option.ExecOption赋值操作
	composite := &ast.CompositeLit{
		Type: astutils.BuildIdentOrSelectorExpr(corePackageName + "." + execOptName),
		Elts: []ast.Expr{
			astutils.BuildKeyValueBasicLitExpr(execOptionFieldSqlStmtName, fmt.Sprintf("%q", sql), token.STRING),
			astutils.BuildKeyValueExpr(execOptionFieldExecerName, astutils.BuildIdentOrSelectorExpr(receiverName+"."+receiverDbFieldName)), // TODO
		},
	}
	optionAssign := &ast.AssignStmt{
		Lhs: []ast.Expr{ast.NewIdent(execOptName)},
		Rhs: []ast.Expr{astutils.BuildUnaryExpr("&", composite)},
	}
	fnDecl.Body.List = append(fnDecl.Body.List, optionAssign)

	// 构建拦截器调用语句
	interceptorCall := astutils.BuildSimpleCallAssign(corePackageName+"."+invokeExecInterceptorName, []*astutils.FuncArg{
		{Name: corePackageName},
		{Name: g.optsName},
	}, true)
	fnDecl.Body.List = append(fnDecl.Body.List, &ast.ExprStmt{X: interceptorCall})

	// 构建数据库操作语句
	dbOptFuncName := dbExecOptName
	if decl.SqlFuncDecl.Annotation == types.SQLSelectFunc {
		dbOptFuncName = dbSelectOptName
	}

	dbCallExpr := astutils.BuildAssignStmtByExpr(astutils.BuildIdentList("_", "err"), []ast.Expr{astutils.BuildSimpleCallAssign()}) // TODO
	fnDecl.Body.List = append(fnDecl.Body.List, dbCallExpr, astutils.BuildIfErrNENilReturn())
	fnDecl.Body.List = append(fnDecl.Body.List, astutils.BuildEmptyStmt())

	switch decl.SqlFuncDecl.Annotation {
	case types.SQLInsertFunc:
	case types.SQLDeleteFunc:
	case types.SQLUpdateFunc:
	case types.SQLSelectFunc:
	default:
		return nil, fmt.Errorf("annotation error")
	}
}

func getExecOptionName(initial string, input, output map[string]*types.Param) string {

}

func getReceiverDbFieldName(param *types.Param) string {

}

func (g *FileGenerator) generateDynamicSqlFuncBodyAst(decl *types.Declaration) (*ast.BlockStmt, error) {

	return nil, nil
}

func (g *FileGenerator) getOptsName(optsName string, inputParm map[string]*types.Param) string {
	for _, v := range inputParm {
		if v.Name == optsName {
			optsName += "1"
			optsName = g.getOptsName(optsName, inputParm)
			break
		}
	}

	return optsName
}

func (g *FileGenerator) generateCode() error {

	trimEmptyLineSign("") // TODO
	return nil
}

func trimEmptyLineSign(source string) string {
	return strings.ReplaceAll(source, astutils.EmptyLineSign, "")
}
