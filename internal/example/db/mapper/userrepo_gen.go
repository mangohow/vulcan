// Code generated by vulcan. DO NOT EDIT.
// version: vulcan v1.0
package mapper

import (
	"database/sql"
	"fmt"
	"github.com/mangohow/vulcan"
	"github.com/mangohow/vulcan/internal/example/model"
	"time"
)

type UserRepo struct {
	db           *sql.DB
	cacheManager vulcan.CacheManger[model.User]
}

func NewUserRepo(db *sql.DB, cacheManager vulcan.CacheManger[model.User]) *UserRepo {
	return &UserRepo{
		db:           db,
		cacheManager: cacheManager,
	}
}

func (m *UserRepo) Add(user *model.User, opts ...vulcan.Option) error {
	option := &vulcan.ExecOption{
		SqlStmt: "INSERT INTO t_user (id, username, password, created_at, email, address) VALUES (?, ?, ?, ?, ?, ?)",
		Args:    []any{user.Id, user.Username, user.Password, user.CreatedAt, user.Email, user.Address},
		Execer:  m.db,
	}
	result, err := vulcan.Invoke(option, func() (sql.Result, error) {
		return option.Exec()
	})
	if err != nil {
		return err
	}

	id, err := result.LastInsertId()
	if err != nil {
		return err
	}
	user.Id = id

	return nil
}

func (m *UserRepo) Add1(user *model.User, opts ...vulcan.Option) (int, error) {
	option := &vulcan.ExecOption{
		SqlStmt: "INSERT INTO t_user (id, username, password, created_at, email, address) VALUES (?, ?, ?, ?, ?, ?)",
		Args:    []any{user.Id, user.Username, user.Password, user.CreatedAt, user.Email, user.Address},
		Execer:  m.db,
	}

	result, err := vulcan.Invoke(option, func() (sql.Result, error) {
		return option.Exec()
	})
	if err != nil {
		return 0, err
	}

	id, err := result.LastInsertId()
	if err != nil {
		return 0, err
	}
	user.Id = id

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	return int(affected), nil
}

func (m *UserRepo) DeleteById(id int, opts ...vulcan.Option) (int, error) {
	option := &vulcan.ExecOption{
		SqlStmt: "DELETE FROM t_user WHERE id = ?",
		Args:    []any{id},
		Execer:  m.db,
	}
	result, err := vulcan.Invoke(option, func() (sql.Result, error) {
		return option.Exec()
	})
	if err != nil {
		return 0, err
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	return int(affected), nil
}

func (m *UserRepo) FindById(id int, opts ...vulcan.Option) (*model.User, error) {
	option := &vulcan.ExecOption{
		SqlStmt: "SELECT id, username, password, created_at, email, address FROM t_user WHERE id = ?",
		Args:    []any{id},
		Execer:  m.db,
	}
	result, err := vulcan.Invoke(option, func() (*model.User, error) {
		res := &model.User{}
		err := option.Get().Scan(&res.Id, &res.Username, &res.Password, &res.CreatedAt, &res.Email, &res.Address)
		return res, err
	})

	if err != nil {
		return nil, err
	}

	return result, nil
}

func (m *UserRepo) UpdateById(user *model.User, opts ...vulcan.Option) (int, error) {
	builder := vulcan.NewSqlBuilder(128, 0, 3)
	builder.AppendStmt("UPDATE t_user ")
	builder.AppendSetStmtConditional(user.Password != "", "password = ?", user.Password).
		AppendSetStmtConditional(user.Email != "", "email = ?", user.Email).
		AppendSetStmtConditional(user.Address != "", "address = ?", user.Address).
		EndSetStmt()
	builder.AppendStmt("WHERE id = ?", user.Id)

	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    builder.Args(),
		Execer:  m.db,
	}

	result, err := vulcan.Invoke(option, func() (sql.Result, error) {
		return option.Exec()
	})
	if err != nil {
		return 0, err
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	return int(affected), nil
}

func (m *UserRepo) Find(user *model.User) (*model.User, error) {
	builder := vulcan.NewSqlBuilder(128, 2, 0)
	builder.AppendStmt("SELECT id, username, password, created_at, email, address FROM t_user ")
	builder.AppendWhereStmtConditional(user.Username != "", "AND username = ?", user.Username).
		AppendWhereStmtConditional(user.Password != "", "AND password = ?", user.Password).
		EndWhereStmt()

	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    builder.Args(),
		Execer:  m.db,
	}

	result, err := vulcan.Invoke(option, func() (*model.User, error) {
		res := &model.User{}
		err := option.Get().Scan(&res.Id, &res.Username, &res.Password, &res.CreatedAt, &res.Email, &res.Address)
		return res, err
	})
	if err != nil {
		return nil, err
	}

	return result, nil
}

func (m *UserRepo) Find2(user *model.User) (model.User, error) {
	builder := vulcan.NewSqlBuilder(128, 2, 0)
	builder.AppendStmt("SELECT id, username, password, created_at, email, address FROM t_user ")
	builder.AppendWhereStmtConditional(user.Username != "", "AND username = ?", user.Username).
		AppendWhereStmtConditional(user.Password != "", "AND password = ?", user.Password).
		EndWhereStmt()

	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    builder.Args(),
		Execer:  m.db,
	}
	result, err := vulcan.Invoke(option, func() (model.User, error) {
		res := model.User{}
		err := option.Get().Scan(&res.Id, &res.Username, &res.Password, &res.CreatedAt, &res.Email, &res.Address)
		return res, err
	})

	if err != nil {
		return model.User{}, err
	}

	return result, nil
}

func (m *UserRepo) BatchAdd(users []*model.User, opts ...vulcan.Option) (int, error) {
	builder := vulcan.NewSqlBuilder(128, 0, 0)
	builder.AppendStmt("INSERT INTO t_user (id, username, password, created_at, email, address) VALUES ")
	vulcan.AppendLoopStmt(builder, users, ", ", "", "", func(user *model.User) []any {
		return []any{user.Id, user.Username, user.Password, user.CreatedAt, user.Email, user.Address}
	}, "(?, ?, ?, ?, ?, ?)")

	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    builder.Args(),
		Execer:  m.db,
	}

	result, err := vulcan.Invoke(option, func() (sql.Result, error) {
		return option.Exec()
	})
	if err != nil {
		return 0, err
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	return int(affected), nil
}

func (m *UserRepo) UpdateByIdOrUsername(user *model.User, opts ...vulcan.Option) error {
	builder := vulcan.NewSqlBuilder(128, 1, 2)
	builder.AppendStmt("UPDATE t_user SET")
	builder.AppendSetStmtConditional(user.Password != "", "password = ?", user.Password).
		AppendSetStmtConditional(user.Email != "", "email = ?", user.Email)
	builder.AppendWhereStmtChoosed(vulcan.MakeSlice(
		vulcan.NewConditionSql(user.Id > 0, "id = ?", user.Id),
		vulcan.NewConditionSql(user.Username != "", "username = ?", user.Username)), "", nil)

	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    builder.Args(),
		Execer:  m.db,
	}

	_, err := vulcan.Invoke(option, func() (sql.Result, error) {
		return option.Exec()
	})
	if err != nil {
		return err
	}

	return nil
}

func (u *UserRepo) SelectPage(page vulcan.Page, cond *model.QueryCond) ([]*model.User, error) {
	builder := vulcan.NewSqlBuilder(128, 2, 0)
	builder.AppendStmt("SELECT id, username, password, created_at, email, address FROM t_user ")
	builder.AppendWhereStmtConditional(cond.Username != "", "AND username = ?", cond.Username).
		AppendWhereStmtConditional(cond.Address != "", "AND address = ?", cond.Address).
		EndWhereStmt()

	option := &vulcan.ExecOption{
		SqlStmt:   builder.String(),
		Args:      builder.Args(),
		Extension: page,
	}

	result, err := vulcan.Invoke(option, func() ([]*model.User, error) {
		res := []*model.User{}
		rows, err := option.Select()
		if err != nil {
			return nil, err
		}
		defer rows.Close()
		for rows.Next() {
			obj := &model.User{}
			err = rows.Scan(&obj.Id, &obj.Username, &obj.Password, &obj.CreatedAt, &obj.Email, &obj.Address)
			if err != nil {
				return nil, err
			}
			res = append(res, obj)
		}
		return res, err
	})

	if err != nil {
		return nil, err
	}

	return result, nil
}

func (u *UserRepo) SelectBatchIds(ids []int) ([]*model.User, error) {
	builder := vulcan.NewSqlBuilder(128, 2, 0)
	builder.AppendStmt("SELECT id, username, password, created_at, email, address FROM t_user WHERE id IN ")
	vulcan.AppendLoopStmt(builder, ids, ", ", "(", ")", func(id int) []any {
		return []any{id}
	}, "?")

	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    builder.Args(),
		Execer:  u.db,
	}

	result, err := vulcan.Invoke(option, func() ([]*model.User, error) {
		res := []*model.User{}
		rows, err := option.Select()
		if err != nil {
			return nil, err
		}
		defer rows.Close()
		for rows.Next() {
			obj := &model.User{}
			err = rows.Scan(&obj.Id, &obj.Username, &obj.Password, &obj.CreatedAt, &obj.Email, &obj.Address)
			if err != nil {
				return nil, err
			}
			res = append(res, obj)
		}
		return res, err
	})

	if err != nil {
		return nil, err
	}

	return result, nil
}

func (m *UserRepo) FindByIdCached(id int, opts ...vulcan.Option) (*model.User, error) {
	option := &vulcan.ExecOption{
		SqlStmt: "SELECT id, username, password, created_at, email, address FROM t_user WHERE id = ?",
		Args:    []any{id},
		Execer:  m.db,
		Ctx: vulcan.CacheableCtx(&vulcan.CacheConfig[model.User]{
			Manager:      m.cacheManager,
			Key:          fmt.Sprintf("user:id:%d", id),
			QueryTimeOut: time.Second * 10,
		}),
	}
	result, err := vulcan.Invoke(option, func() (*model.User, error) {
		res := &model.User{}
		err := option.Get().Scan(&res.Id, &res.Username, &res.Password, &res.CreatedAt, &res.Email, &res.Address)
		return res, err
	})

	if err != nil {
		return nil, err
	}

	return result, nil
}

func (m *UserRepo) UpdateByIdEvict(user *model.User, opts ...vulcan.Option) (int, error) {
	builder := vulcan.NewSqlBuilder(128, 0, 3)
	builder.AppendStmt("UPDATE t_user SET ")
	builder.AppendSetStmtConditional(user.Password != "", "password = ?", user.Password).
		AppendSetStmtConditional(user.Email != "", "email = ?", user.Email).
		AppendSetStmtConditional(user.Address != "", "address = ?", user.Address).
		EndSetStmt()
	builder.AppendStmt("WHERE id = ? ", user.Id)

	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    builder.Args(),
		Execer:  m.db,
		Ctx: vulcan.CacheEvictCtx(&vulcan.CacheConfig[model.User]{
			Manager: m.cacheManager,
			Key:     fmt.Sprintf("user:id:%d", user.Id),
		}),
	}

	result, err := vulcan.Invoke(option, func() (sql.Result, error) {
		return option.Exec()
	})
	if err != nil {
		return 0, err
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	return int(affected), nil
}
