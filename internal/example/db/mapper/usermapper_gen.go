// Code generated by vulcan. DO NOT EDIT.
// version: vulcan v1.0
package mapper

import (
	"fmt"
	"github.com/jmoiron/sqlx"
	"github.com/mangohow/vulcan"
	"github.com/mangohow/vulcan/internal/example/model"
	"time"
)

type Int int

type String string

type Interface interface {
}

type MyTime time.Time

type Fn func()

type Slice []int

type Pointer *int

type TestStruct1 struct {
	t1 int
	t2 string
}

type TestStruct2 struct {
	s1 int
	s2 uint
	s3 bool
	s4 string
	s5 float64
	s6 []byte
	s7 []int
	s8 TestStruct1
	s9 *TestStruct1
}

type UserMapper struct {
	db *sqlx.DB
}

func NewUserMapper(db *sqlx.DB) *UserMapper {
	return &UserMapper{
		db: db,
	}
}

func (m *UserMapper) Add(user *model.User, opts ...vulcan.Option) error {
	option := &vulcan.ExecOption{
		SqlStmt: "INSERT INTO t_user (id, username, password, create_at, email, address) VALUES (?, ?, ?, ?, ?, ?)",
		Args:    []any{user.Id, user.Username, user.Password, user.CreatedAt, user.Email, user.Address},
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	result, err := option.Exec(option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeInsert, nil, err, result))
	if err != nil {
		return err
	}

	id, err := result.LastInsertId()
	if err != nil {
		return err
	}
	user.Id = id

	return nil
}

func (m *UserMapper) Add1(user *model.User, opts ...vulcan.Option) (int, error) {
	option := &vulcan.ExecOption{
		SqlStmt: "INSERT INTO t_user (id, username, password, create_at, email, address) VALUES (?, ?, ?, ?, ?, ?)",
		Args:    []any{user.Id, user.Username, user.Password, user.CreatedAt, user.Email, user.Address},
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	result, err := option.Exec(option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeInsert, nil, err, result))
	if err != nil {
		return 0, err
	}

	id, err := result.LastInsertId()
	if err != nil {
		return 0, err
	}
	user.Id = id

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	return int(affected), nil
}

func (m *UserMapper) DeleteById(id int, opts ...vulcan.Option) (int, error) {
	option := &vulcan.ExecOption{
		SqlStmt: "DELETE FROM t_user WHERE id = ?",
		Args:    []any{id},
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	result, err := option.Exec(option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeDelete, nil, err, result))
	if err != nil {
		return 0, err
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	return int(affected), nil
}

func (m *UserMapper) FindById(id int, opts ...vulcan.Option) (*model.User, error) {
	option := &vulcan.ExecOption{
		SqlStmt: "SELECT * FROM t_user WHERE id = ?",
		Args:    []any{id},
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	res := &model.User{}
	err := option.Select(&res, option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeSelect, res, err, nil))
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (m *UserMapper) UpdatePassword(user *model.User, opts ...vulcan.Option) (int, error) {
	option := &vulcan.ExecOption{
		SqlStmt: "UPDATE t_user SET password = #{user.Password} WHERE id = #{user.Id}",
		Args:    []any{user.Password, user.Username},
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	result, err := option.Exec(option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeUpdate, nil, err, result))
	if err != nil {
		return 0, err
	}
	affected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	return int(affected), nil
}

func (m *UserMapper) UpdateById(user *model.User, opts ...vulcan.Option) (int, error) {
	builder := vulcan.NewSqlBuild(128, 0, 3)
	builder.AppendStmt("UPDATE t_user SET ")
	builder.AppendSetStmtConditional(user.Password != "", user.Password, "password = ?").
		AppendSetStmtConditional(user.Email != "", user.Email, "email = ?").
		AppendSetStmtConditional(user.Address != "", user.Address, "address = ?").
		EndSetStmt()
	builder.AppendStmt("WHERE id = ? ", user.Id)

	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    builder.Args(),
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	result, err := option.Exec(option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeUpdate, nil, err, result))
	if err != nil {
		return 0, err
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	return int(affected), nil
}

func (m *UserMapper) Find(user *model.User) (*model.User, error) {
	builder := vulcan.NewSqlBuild(128, 2, 0)
	builder.AppendStmt("SELECT * FROM t_user")
	builder.AppendWhereStmtConditional(user.Username != "", user.Username, "AND username = ?").
		AppendWhereStmtConditional(user.Password != "", user.Password, "AND password = ?").
		EndWhereStmt()

	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    builder.Args(),
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option)
	res := &model.User{}
	err := option.Select(res, option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeSelect, res, err, nil))
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (m *UserMapper) Find2(user *model.User) (model.User, error) {
	builder := vulcan.NewSqlBuild(128, 2, 0)
	builder.AppendStmt("SELECT * FROM t_user")
	builder.AppendWhereStmtConditional(user.Username != "", user.Username, "AND username = ?").
		AppendWhereStmtConditional(user.Password != "", user.Password, "AND password = ?").
		EndWhereStmt()

	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    builder.Args(),
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option)
	res := model.User{}
	err := option.Select(res, option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeSelect, res, err, nil))
	if err != nil {
		return res, err
	}

	return res, nil
}

func (m *UserMapper) BatchAdd(users []*model.User, opts ...vulcan.Option) (int, error) {
	builder := vulcan.NewSqlBuilderGenerics[*model.User](128, 0, 0)
	builder.AppendStmt("INSERT INTO t_user (id, username, password, create_at, email, address) VALUES ")
	builder.AppendLoopStmt(users, " ", "", "", func(user *model.User) []any {
		return []any{user.Id, user.Username, user.Password, user.CreatedAt, user.Email, user.Address}
	}, "(?, ?, ?, ?, ?, ?)")

	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    builder.Args(),
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	result, err := option.Exec(option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeInsert, nil, err, result))
	if err != nil {
		return 0, err
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	return int(affected), nil
}

func (m *UserMapper) UpdateByIdOrUsername(user *model.User, opts ...vulcan.Option) error {
	builder := vulcan.NewSqlBuild(128, 1, 2)
	builder.AppendStmt("UPDATE t_user SET")
	builder.AppendSetStmtConditional(user.Password != "", user.Password, "password = ?").
		AppendSetStmtConditional(user.Email != "", user.Email, "email = ?")
	builder.AppendWhereStmtChoosed(vulcan.MakeSlice(user.Id > 0, user.Username != ""),
		vulcan.MakeSlice[any](user.Id, user.Username),
		vulcan.MakeSlice("id = ?", "username = ?"))

	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    builder.Args(),
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	result, err := option.Exec(option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeUpdate, nil, err, result))
	if err != nil {
		return err
	}

	return nil
}

func (u *UserMapper) SelectPage(page vulcan.Page, cond *model.QueryCond) ([]*model.User, error) {
	builder := vulcan.NewSqlBuild(128, 2, 0)
	builder.AppendStmt("SELECT * FROM t_user ")
	builder.AppendWhereStmtConditional(cond.Username != "", cond.Username, "AND username = ?").
		AppendWhereStmtConditional(cond.Address != "", cond.Address, "AND address = ?").
		EndWhereStmt()

	option := &vulcan.ExecOption{
		SqlStmt:  builder.String(),
		Args:     builder.Args(),
		FirstArg: page,
	}
	vulcan.InvokePreHandler(option)
	res := []*model.User{}
	err := option.Select(&res, option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeSelect, res, err, nil))
	if err != nil {
		return nil, err
	}

	return res, nil
}

func test() {
	m := model.User{}
	u1 := &m
	u2 := *u1
	_ = u2

	res1 := model.User{}
	res2 := &model.User{}
	res3 := []model.User{}
	res4 := []*model.User{}
	res5 := 0
	res6 := int64(0)
	res7 := ""
	res8 := 0.0
	res9 := true
	res10 := []int{}
	fmt.Println(res1, res2, res3, res4, res5, res6, res7, res8, res9, res10)
}

func test1() (string, error) {
	var err error
	return "", err
}
