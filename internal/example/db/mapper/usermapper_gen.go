// Code generated by vulcan. DO NOT EDIT.
// version: vulcan v1.0
package mapper

import (
	"fmt"
	"github.com/jmoiron/sqlx"
	"github.com/mangohow/vulcan"
	"github.com/mangohow/vulcan/internal/example/model"
	"strings"
	"time"
)

type Int int

type String string

type Interface interface {
}

type MyTime time.Time

type Fn func()

type Slice []int

type Pointer *int

type TestStruct1 struct {
	t1 int
	t2 string
}

type TestStruct2 struct {
	s1 int
	s2 uint
	s3 bool
	s4 string
	s5 float64
	s6 []byte
	s7 []int
	s8 TestStruct1
	s9 *TestStruct1
}

type UserMapper struct {
	db *sqlx.DB
}

func NewUserMapper(db *sqlx.DB) *UserMapper {
	return &UserMapper{
		db: db,
	}
}

func (m *UserMapper) Add(user *model.User, opts ...vulcan.Option) error {
	option := &vulcan.ExecOption{
		SqlStmt: "INSERT INTO t_user (id, username, password, create_at, email, address) VALUES (?, ?, ?, ?, ?, ?)",
		Args:    []any{user.Id, user.Username, user.Password, user.CreatedAt, user.Email, user.Address},
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	result, err := option.Exec(option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeInsert, nil, err, result))
	if err != nil {
		return err
	}

	id, err := result.LastInsertId()
	if err != nil {
		return err
	}
	user.Id = id

	return nil
}

func (m *UserMapper) Add1(user *model.User, opts ...vulcan.Option) (int, error) {
	option := &vulcan.ExecOption{
		SqlStmt: "INSERT INTO t_user (id, username, password, create_at, email, address) VALUES (?, ?, ?, ?, ?, ?)",
		Args:    []any{user.Id, user.Username, user.Password, user.CreatedAt, user.Email, user.Address},
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	result, err := option.Exec(option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeInsert, nil, err, result))
	if err != nil {
		return 0, err
	}

	id, err := result.LastInsertId()
	if err != nil {
		return 0, err
	}
	user.Id = id

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	return int(affected), nil
}

func (m *UserMapper) DeleteById(id int, opts ...vulcan.Option) (int, error) {
	option := &vulcan.ExecOption{
		SqlStmt: "DELETE FROM t_user WHERE id = ?",
		Args:    []any{id},
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	result, err := option.Exec(option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeDelete, nil, err, result))
	if err != nil {
		return 0, err
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	return int(affected), nil
}

func (m *UserMapper) FindById(id int, opts ...vulcan.Option) (*model.User, error) {
	option := &vulcan.ExecOption{
		SqlStmt: "SELECT * FROM t_user WHERE id = ?",
		Args:    []any{id},
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	res := &model.User{}
	err := option.Select(&res, option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeSelect, res, err, nil))
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (m *UserMapper) UpdatePassword(user *model.User, opts ...vulcan.Option) (int, error) {
	option := &vulcan.ExecOption{
		SqlStmt: "UPDATE t_user SET password = #{user.Password} WHERE id = #{user.Id}",
		Args:    []any{user.Password, user.Username},
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	result, err := option.Exec(option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeUpdate, nil, err, result))
	if err != nil {
		return 0, err
	}
	affected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	return int(affected), nil
}

func (m *UserMapper) UpdateById(user *model.User, opts ...vulcan.Option) (int, error) {
	builder := strings.Builder{}
	args := make([]interface{}, 0, 4)
	builder.Grow(128)
	builder.WriteString("UPDATE t_user SET ")
	if user.Password != "" {
		args = append(args, user.Password)
		builder.WriteString("password = ? ")
	}
	if user.Email != "" {
		args = append(args, user.Email)
		builder.WriteString("email = ? ")
	}
	if user.Address != "" {
		args = append(args, user.Address)
		builder.WriteString("address = ? ")
	}
	builder.WriteString("WHERE id = ? ")
	args = append(args, user.Id)
	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    args,
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	result, err := option.Exec(option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeUpdate, nil, err, result))
	if err != nil {
		return 0, err
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	return int(affected), nil
}

func (m *UserMapper) Find(user *model.User) (*model.User, error) {
	builder := strings.Builder{}
	args := make([]interface{}, 0, 2)
	builder.Grow(128)
	builder.WriteString("SELECT * FROM t_user ")
	if user.Username != "" {
		builder.WriteString("WHERE username = ? ")
		args = append(args, user.Username)
	}
	if user.Password != "" {
		builder.WriteString("AND password = ? ")
		args = append(args, user.Password)
	}

	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    args,
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option)
	res := &model.User{}
	err := option.Select(res, option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeSelect, res, err, nil))
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (m *UserMapper) Find2(user *model.User) (model.User, error) {
	builder := strings.Builder{}
	args := make([]interface{}, 0, 2)
	builder.Grow(128)
	builder.WriteString("SELECT * FROM t_user ")
	if user.Username != "" {
		builder.WriteString("WHERE username = ? ")
		args = append(args, user.Username)
	}
	if user.Password != "" {
		builder.WriteString("AND password = ? ")
		args = append(args, user.Password)
	}
	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    args,
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option)
	res := model.User{}
	err := option.Select(res, option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeSelect, res, err, nil))
	if err != nil {
		return res, err
	}

	return res, nil
}

func (m *UserMapper) BatchAdd(users []*model.User, opts ...vulcan.Option) (int, error) {
	builder := strings.Builder{}
	builder.Grow(69 + len(users)*18)
	args := make([]interface{}, 0, 6*len(users))
	builder.WriteString("INSERT INTO t_user (id, username, password, create_at, email, address) VALUES ")
	for i, user := range users {
		args = append(args, user.Id, user.Username, user.Password, user.CreatedAt, user.Email, user.Address)
		if i != 0 {
			builder.WriteString(", ")
		}
		builder.WriteString("(?, ?, ?, ?, ?, ?)")
	}
	builder.WriteString(" ")
	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    args,
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	result, err := option.Exec(option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeInsert, nil, err, result))
	if err != nil {
		return 0, err
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	return int(affected), nil
}

func (m *UserMapper) UpdateByIdOrUsername(user *model.User, opts ...vulcan.Option) error {
	builder := strings.Builder{}
	builder.Grow(64)
	args := make([]interface{}, 0, 3)
	builder.WriteString("UPDATE t_user SET")
	if user.Password != "" {
		builder.WriteString("password = ? ")
		args = append(args, user.Password)
	}
	if user.Email != "" {
		builder.WriteString("email = ? ")
		args = append(args, user.Email)
	}
	builder.WriteString("WHERE ")
	if user.Id > 0 {
		builder.WriteString("id = ? ")
		args = append(args, user.Id)
	} else if user.Username != "" {
		builder.WriteString("username = ? ")
		args = append(args, user.Username)
	}
	option := &vulcan.ExecOption{
		SqlStmt: builder.String(),
		Args:    args,
		Execer:  m.db,
	}
	vulcan.InvokePreHandler(option, opts...)
	result, err := option.Exec(option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeUpdate, nil, err, result))
	if err != nil {
		return err
	}

	return nil
}

func (u *UserMapper) SelectPage(page vulcan.Page, cond *model.QueryCond) ([]*model.User, error) {
	builder := strings.Builder{}
	args := make([]interface{}, 0, 5)
	conds := make([]string, 0, 5)
	builder.WriteString("SELECT * FROM t_user ")
	if cond.Username != "" {
		args = append(args, cond.Username)
		conds = append(conds, "AND username = ? ")
	}
	if cond.Address != "" {
		args = append(args, cond.Address)
		conds = append(conds, "AND address = ? ")
	}
	if len(conds) != 0 {
		builder.WriteString("WHERE 1 = 1 ")
	}
	for _, c := range conds {
		builder.WriteString(c)
	}
	option := &vulcan.ExecOption{
		SqlStmt:  builder.String(),
		Args:     args,
		FirstArg: page,
	}
	vulcan.InvokePreHandler(option)
	res := []*model.User{}
	err := option.Select(&res, option.SqlStmt, option.Args...)
	vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeSelect, res, err, nil))
	if err != nil {
		return nil, err
	}

	return res, nil
}

func test() {
	m := model.User{}
	u1 := &m
	u2 := *u1
	_ = u2

	res1 := model.User{}
	res2 := &model.User{}
	res3 := []model.User{}
	res4 := []*model.User{}
	res5 := 0
	res6 := int64(0)
	res7 := ""
	res8 := 0.0
	res9 := true
	res10 := []int{}
	fmt.Println(res1, res2, res3, res4, res5, res6, res7, res8, res9, res10)
}

func test1() (string, error) {
	var err error
	return "", err
}
