package dbgenerator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"os"
	"reflect"
	"strconv"
	"strings"
	"time"

	"github.com/mangohow/mangokit/tools/collection"
	"github.com/mangohow/mangokit/tools/stream"
	"github.com/mangohow/mangokit/tools/strutil"
	"github.com/mangohow/vulcan/cmd/vulcan/internal/ast/astutils"
	"github.com/mangohow/vulcan/cmd/vulcan/internal/ast/parser/types"
	"github.com/mangohow/vulcan/cmd/vulcan/internal/errors"
	"github.com/mangohow/vulcan/cmd/vulcan/internal/log"
	"github.com/mangohow/vulcan/cmd/vulcan/internal/utils"
	"github.com/mangohow/vulcan/cmd/vulcan/internal/utils/sqlutils"
	"github.com/mangohow/vulcan/cmd/vulcan/internal/version"
)

var (
	fileHeaderComment = fmt.Sprintf("// Code generated by vulcan. DO NOT EDIT.\n// version: vulcan %s\n\n", version.Version)
)

const (
	corePackageName = "vulcan"
	corePackagePath = "github.com/mangohow/vulcan"
)

const (
	execOptionFieldSqlStmtName   = "SqlStmt"
	execOptionFieldArgsName      = "Args"
	execOptionFieldExecerName    = "Execer"
	execOptionFieldExtensionName = "Extension"

	invokePreHandlerName  = "InvokePreHandler"
	invokePostHandlerName = "InvokePostHandler"
	newResultOptionName   = "NewResultOption"

	dbSelectOptName = "Select"
	dbGetOptName    = "Get"
	dbExecOptName   = "Exec"
	dbScanOptName   = "Scan"
	dbRowsCloseName = "Close"
	dbRowsNextName  = "Next"

	sqlTypeInsertName = "SQLTypeInsert"
	sqlTypeUpdateName = "SQLTypeUpdate"
	sqlTypeDeleteName = "SQLTypeDelete"
	sqlTypeSelectName = "SQLTypeSelect"

	nilName = "nil"
	errName = "err"

	entityFiledPrimaryKeyName = "pk"

	lastInsertIdFuncName = "LastInsertId"
	rowsAffectedFuncName = "RowsAffected"

	sqlPackageName     = "sql"
	sqlPackagePathName = "database/sql"
	sqlDBName          = "DB"
)

type FileGenerator struct {
	srcFile  *types.File
	optsName string
}

func NewFileGenerator(file *types.File) *FileGenerator {
	return &FileGenerator{
		srcFile: file,
	}
}

func (g *FileGenerator) Execute(filename string) error {
	for _, d := range g.srcFile.Declarations {
		if d.SqlFuncDecl == nil {
			continue
		}

		if err := g.generateAst(&d); err != nil {
			return errors.Wrapf(err, "func: %s", d.SqlFuncDecl.FuncName)
		}
	}

	return g.generateCode(filename)
}

func (g *FileGenerator) generateAst(decl *types.Declaration) error {
	// 添加opt参数
	fnDecl, ok := decl.AstDecl.(*ast.FuncDecl)
	if !ok {
		return errors.Errorf("convert to *ast.FuncDecl type failed")
	}
	optsMame := g.getOptsName("opts", decl.SqlFuncDecl.InputParam)
	g.optsName = optsMame
	ellipsis := astutils.BuildEllipsisField(optsMame, "vulcan.Option")
	fnDecl.Type.Params.List = append(fnDecl.Type.Params.List, ellipsis)

	// 向函数中添加error返回值
	if fnDecl.Type.Results == nil {
		fnDecl.Type.Results = &ast.FieldList{}
	}
	fnDecl.Type.Results.List = append(fnDecl.Type.Results.List, &ast.Field{
		Type: ast.NewIdent("error"),
	})

	// 生成函数体
	body, err := g.generateFuncBodyAst(decl)
	if err != nil {
		return errors.Wrapf(err, "generate func body error")
	}
	fnDecl.Body = body
	decl.AstDecl = fnDecl

	return nil
}

func (g *FileGenerator) generateFuncBodyAst(decl *types.Declaration) (*ast.BlockStmt, error) {
	sql := decl.SqlFuncDecl.Sql[0]
	switch sql.(type) {
	case types.RawSQL:
		// 处理静态sql
		rawSQL := sql.(types.RawSQL)
		return g.generateStaticSqlFuncBodyAst(decl, rawSQL.Stmt())
	default:
		// 处理静态sql
		return g.generateDynamicSqlFuncBodyAst(decl)
	}
}

func (g *FileGenerator) generateStaticSqlFuncBodyAst(decl *types.Declaration, sql string) (*ast.BlockStmt, error) {
	options, err := preprocessingStaticSqlGen(decl, sql)
	if err != nil {
		return nil, err
	}
	body := &ast.BlockStmt{}

	// 生成option.ExecOption赋值操作
	// option := &vulcan.ExecOption{
	//		SqlStmt: "SELECT ...",
	//		Args:    []any{...},
	//		Execer:  ...,
	//	}
	composite := &ast.CompositeLit{
		Type: astutils.BuildIdentOrSelectorExpr(corePackageName + "." + "ExecOption"),
		Elts: []ast.Expr{
			astutils.BuildKeyValueBasicLitExpr(execOptionFieldSqlStmtName, fmt.Sprintf("%q", options.SQL), token.STRING),
			astutils.BuildKeyValueExpr(execOptionFieldExecerName, astutils.BuildIdentOrSelectorExpr(options.receiverName+"."+options.receiverDbFieldName)),
		},
	}

	// 如果sql参数不为空, 则添加参数
	if len(options.ParamsName) > 0 {
		composite.Elts = append(composite.Elts, astutils.BuildKeyValueExpr(execOptionFieldArgsName, &ast.CompositeLit{
			Type: &ast.ArrayType{
				Elt: ast.NewIdent("any"),
			},
			Elts: stream.Map(options.ParamsName, func(name string) ast.Expr {
				return astutils.BuildIdentOrSelectorExpr(name)
			}),
		}))
	}

	// 如果有扩展字段则需要传入ExecOption
	for _, param := range decl.SqlFuncDecl.InputParam {
		if types.IsRegisteredExtension(param) {
			composite.Elts = append(composite.Elts, astutils.BuildKeyValueBasicLitExpr(execOptionFieldExtensionName, param.Name, token.STRING))
		}
	}

	optionAssign := &ast.AssignStmt{
		Lhs: []ast.Expr{ast.NewIdent(options.execOptionName)},
		Rhs: []ast.Expr{astutils.BuildUnaryExpr("&", composite)},
		Tok: token.DEFINE,
	}
	body.List = append(body.List, optionAssign)

	// 构建拦截器preHandle调用语句
	// vulcan.InvokePreHandler(option, opts...)
	preInterceptorCall := astutils.BuildSimpleCallAssign(corePackageName+"."+invokePreHandlerName, []*astutils.FuncArg{
		{Name: options.execOptionName},
		{Name: g.optsName},
	}, true)
	body.List = append(body.List, &ast.ExprStmt{X: preInterceptorCall})

	// 如果是select语句, 则需要new一个对象
	// res := &pkg.Struct{}
	if decl.SqlFuncDecl.Annotation == types.SQLSelectFunc {
		assignStmt := astutils.BuildInitAssignExpr(decl.SqlFuncDecl.FuncReturnResultParam, options.sqlOperationResultName, decl.PkgInfo.PackageName)
		body.List = append(body.List, assignStmt)
	}

	var (
		queryStmt      ast.Stmt
		selectScanFunc func() []ast.Stmt
	)
	// 构建数据库操作语句
	if decl.SqlFuncDecl.Annotation == types.SQLSelectFunc {
		returnType := &decl.SqlFuncDecl.FuncReturnResultParam.Type
		if returnType.IsSlice() {
			// 处理批量查询
			// rows, err := option.Select(option.SqlStmt, option.Args...)
			queryStmt, selectScanFunc = g.generateDBSelectStmt(decl, options)
		} else {
			// 处理单条记录的查询
			// err := option.Get(option.SqlStmt, option.Args...).Scan(&res.Id, ...)
			queryStmt = g.generateDBGetStmt(decl, options)
		}
		body.List = append(body.List, queryStmt)
	} else {
		// 处理sql执行语句
		// result, err := option.Exec(option.SqlStmt, option.Args...)
		execArgs := make([]*astutils.FuncArg, 0, 3)
		execArgs = append(execArgs, stream.Map(options.sqlExecuteArgsName, func(v string) *astutils.FuncArg {
			return &astutils.FuncArg{Name: v}
		})...)
		dbCallExpr := astutils.BuildDefineStmtByExpr(astutils.BuildIdentList(options.sqlExecuteResultName...),
			[]ast.Expr{astutils.BuildSimpleCallAssign(options.execOptionName+"."+options.sqlOperationName, execArgs, true)})
		body.List = append(body.List, dbCallExpr)
	}

	// 构建拦截器postHandle调用语句
	// vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeUpdate, nil, err, result))
	postInterceptorCall := astutils.BuildCallExpr(astutils.BuildIdentOrSelectorExpr(corePackageName+"."+invokePostHandlerName), []ast.Expr{
		astutils.BuildSimpleCallAssign(corePackageName+"."+newResultOptionName, stream.Map(options.newResultOptionArgsName, func(v string) *astutils.FuncArg {
			return &astutils.FuncArg{Name: v}
		}), false),
	}, false)
	body.List = append(body.List, &ast.ExprStmt{X: postInterceptorCall})

	// 构建err判断语句
	// if err != nil {
	//		return err
	//	}
	body.List = append(body.List, g.generateReturnErrAst(decl.SqlFuncDecl.FuncReturnResultParam, options.sqlOperationResultName, decl.SqlFuncDecl.Annotation))

	// 如果是查询列表, 则需要生成for循环Scan语句
	// defer rows.Close()
	//	for rows.Next() {
	//		obj := &model.User{}
	//		rows.Scan(&obj.Id, ...)
	//		res = append(res, obj)
	//	}
	if selectScanFunc != nil {
		body.List = append(body.List, selectScanFunc()...)
	}

	// 如果是插入语句, 可能需要给自增Id赋值
	// id, err := result.LastInsertId()
	//	if err != nil {
	//		return 0, err
	//	}
	//	user.Id = id
	if decl.SqlFuncDecl.Annotation == types.SQLInsertFunc {
		stmts := g.generatePrimaryKeyAssign(options, decl)
		if len(stmts) > 0 {
			// 添加空行
			body.List = append(body.List, astutils.BuildEmptyStmt())
			body.List = append(body.List, stmts...)
		}
	}

	if decl.SqlFuncDecl.FuncReturnResultParam != nil {
		// 如果是增删改语句, 可能需要返回rowAffected
		// affected, err := result.RowsAffected()
		//	if err != nil {
		//		return 0, err
		//	}
		// return int(affected), nil
		rowsAffectedStmt := g.generateRowAffectedAssignAndReturnStmt(options, decl)
		body.List = append(body.List, astutils.BuildEmptyStmt())
		body.List = append(body.List, rowsAffectedStmt...)
	} else {
		// 直接构建返回语句
		// return nil
		body.List = append(body.List, astutils.BuildEmptyStmt())
		body.List = append(body.List, astutils.BuildReturnStmt("nil"))
	}

	return body, nil
}

// 构建if err != nil {}
// return语句: return 0, err
// return nil, err
// return false, err
// return res, err
func (g *FileGenerator) generateReturnErrAst(param *types.Param, sqlExecuteResultName, sqlType string) *ast.IfStmt {
	if param == nil {
		return astutils.BuildIfErrNENilReturn("err")
	}

	if param.Type.IsPointer() || param.Type.IsSlice() {
		return astutils.BuildIfErrNENilReturn("nil", "err")
	}

	returnArgs := make([]interface{}, 0, 2)
	switch sqlType {
	case types.SQLInsertFunc, types.SQLDeleteFunc, types.SQLUpdateFunc:
		switch param.Type.Kind {
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
			reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
			returnArgs = append(returnArgs, 0, "err")
		case reflect.Bool:
			returnArgs = append(returnArgs, false, "err")
		case reflect.String:
			returnArgs = append(returnArgs, `""`, "err")
		case reflect.Float32, reflect.Float64:
			returnArgs = append(returnArgs, 0.0, "err")
		}
	case types.SQLSelectFunc:
		returnArgs = append(returnArgs, sqlExecuteResultName, "err")
	}

	return astutils.BuildIfErrNENilReturn(returnArgs...)
}

// 构建给主键赋值的语句
// lastInsertedId, err := result.LastInsertId()
//
//	if err != nil {
//	    return 0, err
//	}
//
// user.Id = lastInsertedId
func (g *FileGenerator) generatePrimaryKeyAssign(options *staticSqlGenOptions, decl *types.Declaration) []ast.Stmt {
	var (
		findPrimaryKey func(param *types.Param) *types.Param
		names          []string
	)
	findPrimaryKey = func(param *types.Param) *types.Param {
		if param == nil {
			return nil
		}
		if param.Type.IsSlice() {
			return nil
		}
		if param.Type.IsPointer() {
			return findPrimaryKey(&types.Param{Name: param.Name, Type: *param.Type.ValueType})
		}

		if param.Type.IsBasicType() {
			if tag := param.Type.Tag.Get("db"); tag != "" && strings.Contains(tag, entityFiledPrimaryKeyName) {
				return param
			}
		}

		names = append(names, param.Name)
		for _, field := range param.Type.Fields {
			pkType := findPrimaryKey(field)
			if pkType != nil {
				names = append(names, field.Name)
				return pkType
			}
		}

		return nil
	}

	var (
		pkParam *types.Param
	)
	inputParams := utils.Values(decl.SqlFuncDecl.InputParam)
	for i := 0; i < len(inputParams); i++ {
		pkParam = findPrimaryKey(inputParams[i])
		if pkParam != nil {
			break
		}
	}

	if pkParam == nil {
		return nil
	}

	switch pkParam.Type.Kind {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
	default:
		return nil
	}

	// 构建 lastInsertedId, err := result.LastInsertId()
	assignStmt := astutils.BuildCallAssign([]string{options.lastInsertedIdName, "err"}, ":=", options.sqlExecuteResultName[0]+"."+lastInsertIdFuncName, nil, false)
	// 构建if err != nil {return err}
	errReturnStmt := g.generateReturnErrAst(decl.SqlFuncDecl.FuncReturnResultParam, options.sqlExecuteResultName[0], decl.SqlFuncDecl.Annotation)
	// 构建主键赋值
	var idAssignStmt ast.Stmt
	if pkParam.Type.Kind == reflect.Int64 {
		idAssignStmt = astutils.BuildAssignStmt([]string{strings.Join(names, ".")}, []string{options.lastInsertedIdName})
	} else {
		idAssignStmt = astutils.BuildCallAssign([]string{strings.Join(names, ".")}, "=", pkParam.Type.Kind.String(), []*astutils.FuncArg{
			{Name: options.lastInsertedIdName},
		}, false)
	}

	return []ast.Stmt{assignStmt, errReturnStmt, astutils.BuildEmptyStmt(), idAssignStmt}
}

func (g *FileGenerator) generateRowAffectedAssignAndReturnStmt(options *staticSqlGenOptions, decl *types.Declaration) []ast.Stmt {
	if decl.SqlFuncDecl.Annotation == types.SQLSelectFunc || decl.SqlFuncDecl.FuncReturnResultParam == nil {
		return []ast.Stmt{astutils.BuildReturnStmt(options.sqlOperationResultName, "nil")}
	}

	assignStmt := astutils.BuildCallAssign([]string{options.rowsAffectedName, "err"}, ":=", options.sqlExecuteResultName[0]+"."+rowsAffectedFuncName, nil, false)
	errReturnStmt := g.generateReturnErrAst(decl.SqlFuncDecl.FuncReturnResultParam, options.sqlExecuteResultName[0], decl.SqlFuncDecl.Annotation)
	var returnStmt ast.Stmt
	if decl.SqlFuncDecl.FuncReturnResultParam.Type.Kind == reflect.Int64 {
		returnStmt = astutils.BuildReturnStmt(options.rowsAffectedName, "nil")
	} else {
		returnStmt = astutils.BuildReturnStmtByExpr(astutils.BuildCallExpr(ast.NewIdent(decl.SqlFuncDecl.FuncReturnResultParam.Type.Kind.String()), []ast.Expr{ast.NewIdent(options.rowsAffectedName)}, false), ast.NewIdent("nil"))
	}

	return []ast.Stmt{assignStmt, errReturnStmt, astutils.BuildEmptyStmt(), returnStmt}
}

type staticSqlGenOptions struct {
	*sqlutils.SqlParseResult
	execOptionName          string
	receiverName            string
	receiverDbFieldName     string
	sqlOperationName        string
	sqlOperationResultName  string
	sqlExecuteResultName    []string
	sqlExecuteArgsName      []string
	lastInsertedIdName      string
	rowsAffectedName        string
	newResultOptionArgsName []string
	selectRowsName          string
	selectObjName           string
}

// 对静态sql的代码生成进行预处理
func preprocessingStaticSqlGen(decl *types.Declaration, sql string) (*staticSqlGenOptions, error) {
	usedNames := collection.NewSetFromSlice[string](utils.Keys(decl.SqlFuncDecl.InputParam))
	if decl.SqlFuncDecl.Receiver != nil {
		usedNames.Add(decl.SqlFuncDecl.Receiver.Name)
	}
	for _, v := range decl.SqlFuncDecl.OutputParam {
		if v.Name != "" {
			usedNames.Add(v.Name)
		}
	}

	sqlInfo := decl.SqlFuncDecl.SqlParseResult
	sqlInfo.SQL = sql

	var (
		sqlOperationName     = dbExecOptName
		sqlExecuteResultName = []string{getAvailableName("result", usedNames), "err"}
		options              = &staticSqlGenOptions{
			execOptionName:         getAvailableName("option", usedNames),
			receiverName:           decl.SqlFuncDecl.Receiver.Name,
			receiverDbFieldName:    getReceiverDbFieldName(decl.SqlFuncDecl.Receiver),
			SqlParseResult:         sqlInfo,
			sqlOperationResultName: getAvailableName("res", usedNames),
			lastInsertedIdName:     getAvailableName("lasInsertedId", usedNames),
			rowsAffectedName:       getAvailableName("rowsAffected", usedNames),
			selectRowsName:         getAvailableName("rows", usedNames),
			selectObjName:          getAvailableName("obj", usedNames),
		}
	)

	options.sqlExecuteArgsName = append(options.sqlExecuteArgsName, options.execOptionName+"."+execOptionFieldSqlStmtName, options.execOptionName+"."+execOptionFieldArgsName)
	switch decl.SqlFuncDecl.Annotation {
	case types.SQLInsertFunc:
		options.newResultOptionArgsName = append(options.newResultOptionArgsName, corePackageName+"."+sqlTypeInsertName, nilName, errName, sqlExecuteResultName[0])
	case types.SQLDeleteFunc:
		options.newResultOptionArgsName = append(options.newResultOptionArgsName, corePackageName+"."+sqlTypeDeleteName, nilName, errName, sqlExecuteResultName[0])
	case types.SQLUpdateFunc:
		options.newResultOptionArgsName = append(options.newResultOptionArgsName, corePackageName+"."+sqlTypeUpdateName, nilName, errName, sqlExecuteResultName[0])
	case types.SQLSelectFunc:
		sqlOperationName = dbGetOptName
		if decl.SqlFuncDecl.FuncReturnResultParam == nil {
			return nil, errors.Errorf("Select statement must have two returning parameters")
		}
		if decl.SqlFuncDecl.FuncReturnResultParam.Type.IsSlice() {
			sqlOperationName = dbSelectOptName
		}
		sqlExecuteResultName = sqlExecuteResultName[1:]
		options.newResultOptionArgsName = append(options.newResultOptionArgsName, corePackageName+"."+sqlTypeSelectName, options.sqlOperationResultName, errName, nilName)
	default:
		return nil, errors.Errorf("annotation error")
	}

	options.sqlOperationName = sqlOperationName
	options.sqlExecuteResultName = sqlExecuteResultName

	return options, nil
}

// 防止函数body中出现的变量名和函数参数名称出现重复
func getAvailableName(initial string, usedNames collection.Set[string]) string {
	if !usedNames.Has(initial) {
		usedNames.Add(initial)
		return initial
	}

	initial += "x"

	return getAvailableName(initial, usedNames)
}

func getReceiverDbFieldName(param *types.Param) string {
	if param.Type.IsPointer() {
		return getReceiverDbFieldName(&types.Param{Name: param.Name, Type: *param.Type.ValueType})
	}

	for _, field := range param.Type.Fields {
		typeSpec := &field.Type
		if field.Type.IsPointer() {
			typeSpec = field.Type.ValueType
		}
		if typeSpec.Name == sqlDBName && typeSpec.Package.PackageName == sqlPackageName && typeSpec.Package.PackagePath == sqlPackagePathName {
			return field.Name
		}
	}

	return ""
}

func (g *FileGenerator) generateDynamicSqlFuncBodyAst(decl *types.Declaration) (*ast.BlockStmt, error) {
	blockStmt := &ast.BlockStmt{}

	var (
		whereInitial, setInitial = g.statisticsInitialCapacity(decl.SqlFuncDecl.Sql)
		builderAssignExpr        *ast.AssignStmt
		genericsName             = ""
		genericsStar             = false
		builderVarName           = "builder" // TODO builder可能不可用
	)
	if stmt := g.findForeachStmt(decl.SqlFuncDecl.Sql); stmt != nil {
		param := decl.SqlFuncDecl.InputParam[stmt.CollectionName]
		if !param.Type.IsSlice() {
			return nil, errors.Errorf("param %s is not slice type", stmt.CollectionName)
		}

		valueType := &param.Type

		if valueType.IsPointer() {
			genericsStar = true
			valueType = valueType.ValueType
		}
		if valueType.Package == nil {
			genericsName = valueType.Name
		} else {
			genericsName = valueType.Package.PackageName + "." + valueType.Name
		}
	}

	builderAssignExpr = astutils.BuildCallAssignGenerics([]string{builderVarName}, ":=", "vulcan.NewSqlBuilderGenerics", []*astutils.FuncArg{
		{Name: strconv.Itoa(128), BasicLitFlag: token.INT},
		{Name: strconv.Itoa(whereInitial), BasicLitFlag: token.INT},
		{Name: strconv.Itoa(setInitial), BasicLitFlag: token.INT},
	}, genericsName, genericsStar, false)
	blockStmt.List = append(blockStmt.List, builderAssignExpr)

	// 生成动态sql代码Ast
	for _, sql := range decl.SqlFuncDecl.Sql {
		var added ast.Stmt
		switch stmt := sql.(type) {
		case *types.WhereStmt:
			added = g.generateWhereStmtAst(stmt, builderVarName)
		case *types.SetStmt:
			added = g.generateSetStmtAst(stmt, builderVarName)
		case *types.IfStmt:
			added = g.generateIfStmtAst(stmt, builderVarName)
		case *types.ForeachStmt:
			added = g.generateForeachStmtAst(stmt, builderVarName)
		case *types.SimpleStmt:
			added = g.generateSimpleStmtAst(stmt, builderVarName)
		default:
			return nil, errors.Errorf("unknown annotaion type: %T", sql)
		}
		blockStmt.List = append(blockStmt.List, added)
	}

	return blockStmt, nil
}

func (g *FileGenerator) generateWhereStmtAst(stmt *types.WhereStmt, builderVarName string) ast.Stmt {

	return nil
}

func (g *FileGenerator) generateSetStmtAst(stmt *types.SetStmt, builderVarName string) ast.Stmt {

	return nil
}

func (g *FileGenerator) generateIfStmtAst(stmt *types.IfStmt, builderVarName string) ast.Stmt {

	return nil
}

func (g *FileGenerator) generateForeachStmtAst(stmt *types.ForeachStmt, builderVarName string) ast.Stmt {

	return nil
}

func (g *FileGenerator) generateSimpleStmtAst(stmt *types.SimpleStmt, builderVarName string) ast.Stmt {

	return nil
}

func (g *FileGenerator) findForeachStmt(sqls []types.SQL) *types.ForeachStmt {
	for _, sql := range sqls {
		if stmt, ok := sql.(*types.ForeachStmt); ok {
			return stmt
		}
	}

	return nil
}

func (g *FileGenerator) statisticsInitialCapacity(sqls []types.SQL) (int, int) {
	var (
		whereInitial, setInitial int
	)

	for _, sql := range sqls {
		switch stmt := sql.(type) {
		case types.WhereStmt:
			ifChainStmt, ok := stmt.Cond.(*types.IfChainStmt)
			if !ok {
				break
			}
			whereInitial += len(ifChainStmt.Stmts)
		case types.SetStmt:
			ifChainStmt, ok := stmt.Cond.(*types.IfChainStmt)
			if !ok {
				break
			}
			setInitial += len(ifChainStmt.Stmts)
		}
	}

	return whereInitial, setInitial
}

func (g *FileGenerator) getOptsName(optsName string, inputParm map[string]*types.Param) string {
	for _, v := range inputParm {
		if v.Name == optsName {
			optsName += "1"
			optsName = g.getOptsName(optsName, inputParm)
			break
		}
	}

	return optsName
}

func (g *FileGenerator) generateCode(filename string) error {
	astFile := &ast.File{
		Name:    g.srcFile.AstFile.Name,
		Imports: g.srcFile.PkgInfo.AstImports,
	}
	importGenDecl := &ast.GenDecl{
		Tok: token.IMPORT,
	}
	set := collection.NewSet[string]()
	for _, importSpec := range g.srcFile.PkgInfo.AstImports {
		if !set.Has(importSpec.Path.Value) {
			importGenDecl.Specs = append(importGenDecl.Specs, importSpec)
			set.Add(importSpec.Path.Value)
		}
	}
	astFile.Decls = append(astFile.Decls, importGenDecl)

	tempName := strutil.RandString(8) + strconv.Itoa(int(time.Now().UnixNano()))
	astFile.Decls = append(astFile.Decls, stream.Map(g.srcFile.Declarations, func(t types.Declaration) ast.Decl {
		// 处理结构体单字段生成不会换行的问题
		genDecl, ok := t.AstDecl.(*ast.GenDecl)
		if !ok {
			return t.AstDecl
		}

		stream.ForEach(genDecl.Specs, func(spec ast.Spec) bool {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				return true
			}
			if typeSpec.Type == nil {
				return true
			}

			st, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				return true
			}

			if st.Fields == nil || len(st.Fields.List) != 1 {
				return true
			}

			st.Fields.List = append(st.Fields.List, &ast.Field{
				Names: []*ast.Ident{ast.NewIdent("_")},
				Type:  ast.NewIdent(tempName),
			})

			return true
		})

		return t.AstDecl
	})...)

	buffer := bytes.NewBuffer(nil)
	err := format.Node(buffer, token.NewFileSet(), astFile)
	if err != nil {
		return errors.Errorf("generate source code error: %v", err)
	}

	source := buffer.String()
	// 替换空行
	source = trimEmptyLineSign(source)

	// 在所有类型声明和函数声明前面加一个空行
	r := strings.NewReplacer([]string{
		"\nfunc", "\n\nfunc",
		"\ntype ", "\ntype ",
	}...)
	source = r.Replace(source)
	// 控制声明块之间只有一个空行
	source = strings.ReplaceAll(source, "\n\n\n", "\n\n")

	// 所有的结构体初始化, key:val添加换行
	const startKey = "vulcan.ExecOption{SqlStmt"
	const endKey = "}\n"
	replacer := strings.NewReplacer([]string{
		startKey, "vulcan.ExecOption{\n\t\tSqlStmt",
		", Execer:", ",\n\t\tExecer:",
		", Args:", ",\n\t\tArgs:",
		", Extension:", ",\n\t\tExtension:",
		endKey, ",\n\t}\n",
	}...)
	for {
		idx1 := strings.Index(source, startKey)
		if idx1 == -1 {
			break
		}
		idx2 := strings.Index(source[idx1:], endKey)
		fragment := source[idx1 : idx1+idx2+len(endKey)]
		fragment = replacer.Replace(fragment)
		source = source[:idx1] + fragment + source[idx1+idx2+len(endKey):]
	}

	// 处理占位结构体字段
	for {
		idx1 := strings.Index(source, tempName)
		if idx1 == -1 {
			break
		}
		idx2 := strings.LastIndex(source[:idx1], "\n")

		source = source[:idx2] + source[idx1+len(tempName):]
	}

	file, err := os.OpenFile(filename, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0644)
	if err != nil {
		return errors.Errorf("open file %s error: %v", filename, err)
	}
	defer file.Close()

	fmt.Fprint(file, fileHeaderComment)
	fmt.Fprint(file, source)

	log.Infof("Generate go file %s!", filename)
	return nil
}

func (g *FileGenerator) generateDBSelectStmt(decl *types.Declaration, options *staticSqlGenOptions) (ast.Stmt, func() []ast.Stmt) {
	// 构建Select查询语句
	selectStmt := astutils.BuildCallAssign([]string{options.selectRowsName, "err"}, ":=", options.execOptionName+"."+dbSelectOptName, []*astutils.FuncArg{
		{
			Name: options.execOptionName + "." + execOptionFieldSqlStmtName,
		},
		{
			Name: options.execOptionName + "." + execOptionFieldArgsName,
		},
	}, true)

	return selectStmt, func() []ast.Stmt {
		// 构建defer语句
		deferStmt := &ast.DeferStmt{
			Call: &ast.CallExpr{
				Fun: astutils.BuildSelectorExpr([]string{options.selectRowsName, dbRowsCloseName}),
			},
		}
		// 构建for循环
		forStmt := &ast.ForStmt{
			Cond: &ast.CallExpr{
				Fun: astutils.BuildSelectorExpr([]string{options.selectRowsName, dbRowsNextName}),
			},
			Body: &ast.BlockStmt{},
		}
		valueType := decl.SqlFuncDecl.FuncReturnResultParam.Type.ValueType
		param := &types.Param{Type: *valueType}
		// 构建对象声明语句
		initAssignExpr := astutils.BuildInitAssignExpr(param, options.selectObjName, decl.PkgInfo.PackageName)
		// 构建Scan语句
		var scanFuncArgs []*astutils.FuncArg
		if decl.SqlFuncDecl.FuncReturnResultParam.Type.GetValueType().IsBasicType() {
			scanFuncArgs = []*astutils.FuncArg{{Name: options.selectObjName, AndFlag: true}}
		} else {
			scanFuncArgs = stream.Map(decl.SqlFuncDecl.SelectFields, func(name string) *astutils.FuncArg {
				return &astutils.FuncArg{Name: options.selectObjName + "." + name, AndFlag: true}
			})
		}
		scanCallExpr := astutils.BuildCallAssign([]string{"err"}, "=", options.selectRowsName+"."+dbScanOptName, scanFuncArgs, false)
		// 构建if err != nil 判断
		errReturnStmt := g.generateReturnErrAst(decl.SqlFuncDecl.FuncReturnResultParam, options.sqlOperationResultName, decl.SqlFuncDecl.Annotation)
		// 构建append语句
		appendStmt := astutils.BuildCallAssign([]string{options.sqlOperationResultName}, "=", "append", []*astutils.FuncArg{
			{Name: options.sqlOperationResultName},
			{Name: options.selectObjName},
		}, false)
		forStmt.Body.List = []ast.Stmt{initAssignExpr, scanCallExpr, errReturnStmt, appendStmt}

		return []ast.Stmt{deferStmt, forStmt}
	}
}

func (g *FileGenerator) generateDBGetStmt(decl *types.Declaration, options *staticSqlGenOptions) ast.Stmt {
	// 构建option.Get(arg1, arg2).Scan(arg3, arg4, ...)语句
	// 先构建option.Get()
	getExpr := astutils.BuildCallExpr(astutils.BuildSelectorExpr([]string{options.execOptionName, dbGetOptName}), []ast.Expr{
		astutils.BuildSelectorExpr([]string{options.execOptionName, execOptionFieldSqlStmtName}),
		astutils.BuildSelectorExpr([]string{options.execOptionName, execOptionFieldArgsName}),
	}, true)

	var scanArgsExpr []ast.Expr
	if decl.SqlFuncDecl.FuncReturnResultParam.Type.GetValueType().IsBasicType() {
		scanArgsExpr = []ast.Expr{astutils.BuildUnaryExpr("&", ast.NewIdent(options.sqlOperationResultName))}
	} else {
		scanArgsExpr = stream.Map(decl.SqlFuncDecl.SelectFields, func(name string) ast.Expr {
			return astutils.BuildUnaryExpr("&", astutils.BuildSelectorExpr([]string{options.sqlOperationResultName, name}))
		})
	}
	// 构建.Scan()
	scanExpr := &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   getExpr,
			Sel: ast.NewIdent(dbScanOptName),
		},
		Args: scanArgsExpr,
	}
	callAssignStmt := astutils.BuildDefineStmtByExpr([]ast.Expr{ast.NewIdent("err")}, []ast.Expr{scanExpr})
	return callAssignStmt
}

func trimEmptyLineSign(source string) string {
	return strings.ReplaceAll(source, astutils.EmptyLineSign, "")
}
