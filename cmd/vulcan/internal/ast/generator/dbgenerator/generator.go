package dbgenerator

import (
	"bytes"
	"fmt"
	"github.com/mangohow/vulcan/cmd/vulcan/internal/ast/astutils"
	"go/ast"
	"go/format"
	"go/token"
	"math/bits"
	"os"
	"os/exec"
	"reflect"
	"strconv"
	"strings"
	"time"

	"github.com/mangohow/mangokit/tools/collection"
	"github.com/mangohow/mangokit/tools/stream"
	"github.com/mangohow/mangokit/tools/strutil"

	"github.com/mangohow/vulcan/cmd/vulcan/internal/ast/parser/types"
	"github.com/mangohow/vulcan/cmd/vulcan/internal/errors"
	"github.com/mangohow/vulcan/cmd/vulcan/internal/log"
	"github.com/mangohow/vulcan/cmd/vulcan/internal/utils"
	"github.com/mangohow/vulcan/cmd/vulcan/internal/utils/sqlutils"
	"github.com/mangohow/vulcan/cmd/vulcan/internal/version"
)

var (
	fileHeaderComment = fmt.Sprintf("// Code generated by vulcan. DO NOT EDIT.\n// version: vulcan %s\n\n", version.Version)
)

const (
	corePackageName = "vulcan"
	corePackagePath = "github.com/mangohow/vulcan"
)

const (
	execOptionFieldSqlStmtName   = "SqlStmt"
	execOptionFieldArgsName      = "Args"
	execOptionFieldExecerName    = "Execer"
	execOptionFieldExtensionName = "Extension"

	invokePreHandlerName  = "InvokePreHandler"
	invokePostHandlerName = "InvokePostHandler"
	newResultOptionName   = "NewResultOption"

	dbSelectOptName = "Select"
	dbGetOptName    = "Get"
	dbExecOptName   = "Exec"
	dbScanOptName   = "Scan"
	dbRowsCloseName = "Close"
	dbRowsNextName  = "Next"

	sqlTypeInsertName = "SQLTypeInsert"
	sqlTypeUpdateName = "SQLTypeUpdate"
	sqlTypeDeleteName = "SQLTypeDelete"
	sqlTypeSelectName = "SQLTypeSelect"

	nilName = "nil"
	errName = "err"

	entityFiledPrimaryKeyName = "pk"

	lastInsertIdFuncName = "LastInsertId"
	rowsAffectedFuncName = "RowsAffected"

	sqlPackageName     = "sql"
	sqlPackagePathName = "database/sql"
	sqlDBName          = "DB"

	sqlBuilderFuncAppendStmt                   = "AppendStmt"
	sqlBuilderFuncAppendWhereStmtConditional   = "AppendWhereStmtConditional"
	sqlBuilderFuncAppendAppendWhereStmtChoosed = "AppendWhereStmtChoosed"
	sqlBuilderFuncEndWhereStmt                 = "EndWhereStmt"
	sqlBuilderFuncAppendSetStmtConditional     = "AppendSetStmtConditional"
	sqlBuilderFuncAppendSetStmtChoosed         = "AppendSetStmtChoosed"
	sqlBuilderFuncEndSetStmt                   = "EndSetStmt"
	sqlBuilderFuncAppendStmtConditional        = "AppendStmtConditional"
	sqlBuilderFuncAppendLoopStmt               = "AppendLoopStmt"
	sqlBuilderFuncString                       = "String"
	sqlBuilderFuncArgs                         = "Args"

	funcNameNewSqlBuilder   = "NewSqlBuilder"
	funcNameNewConditionSql = "NewConditionSql"
	funcNameMakeSlice       = "MakeSlice"
)

type FileGenerator struct {
	srcFile  *types.File
	optsName string
}

func NewFileGenerator(file *types.File) *FileGenerator {
	return &FileGenerator{
		srcFile: file,
	}
}

func (g *FileGenerator) Execute(filename string) error {
	for _, d := range g.srcFile.Declarations {
		if d.SqlFuncDecl == nil {
			continue
		}

		if err := g.generateAst(&d); err != nil {
			return errors.Wrapf(err, "func: %s", d.SqlFuncDecl.FuncName)
		}
	}

	if err := g.generateCode(filename); err != nil {
		return err
	}

	// 格式化代码
	err := exec.Command("go", "fmt", filename).Run()
	if err != nil {
		log.Errorf("run go fmt failed, %v", err)
	}

	return nil
}

func (g *FileGenerator) generateAst(decl *types.Declaration) error {
	// 添加opt参数
	fnDecl, ok := decl.AstDecl.(*ast.FuncDecl)
	if !ok {
		return errors.Errorf("convert to *ast.FuncDecl type failed")
	}
	optsMame := g.getOptsName("opts", decl.SqlFuncDecl.InputParam)
	g.optsName = optsMame
	ellipsis := astutils.BuildEllipsisField(optsMame, "vulcan.Option")
	fnDecl.Type.Params.List = append(fnDecl.Type.Params.List, ellipsis)

	// 向函数中添加error返回值
	if fnDecl.Type.Results == nil {
		fnDecl.Type.Results = &ast.FieldList{}
	}
	fnDecl.Type.Results.List = append(fnDecl.Type.Results.List, &ast.Field{
		Type: ast.NewIdent("error"),
	})

	// 生成函数体
	body, err := g.generateFuncBodyAst(decl)
	if err != nil {
		return errors.Wrapf(err, "generate func body error")
	}
	fnDecl.Body = body
	decl.AstDecl = fnDecl

	return nil
}

func (g *FileGenerator) generateFuncBodyAst(decl *types.Declaration) (*ast.BlockStmt, error) {
	sql := decl.SqlFuncDecl.Sql[0]
	switch sql.(type) {
	case types.RawSQL:
		// 处理静态sql
		rawSQL := sql.(types.RawSQL)
		options, err := preprocessingStaticSqlGen(decl, rawSQL.Stmt())
		if err != nil {
			return nil, err
		}
		return g.generateStaticSqlFuncBodyAst(decl, options)
	default:
		// 处理静态sql
		options, err := preprocessingStaticSqlGen(decl, "")
		if err != nil {
			return nil, err
		}
		return g.generateDynamicSqlFuncBodyAst(decl, options)
	}
}

func (g *FileGenerator) generateStaticSqlFuncBodyAst(decl *types.Declaration, options *sqlGenOptions) (*ast.BlockStmt, error) {
	body := &ast.BlockStmt{}
	stmts, err := g.generateCommonCode(decl, options, false)
	if err != nil {
		return nil, err
	}
	body.List = stmts

	return body, nil
}

// 构建if err != nil {}
// return语句: return 0, err
// return nil, err
// return false, err
// return res, err
func (g *FileGenerator) generateReturnErrAst(param *types.Param, sqlExecuteResultName, sqlType string) *ast.IfStmt {
	if param == nil {
		return astutils.BuildIfErrNENilReturn("err")
	}

	if param.Type.IsPointer() || param.Type.IsSlice() {
		return astutils.BuildIfErrNENilReturn("nil", "err")
	}

	returnArgs := make([]interface{}, 0, 2)
	switch sqlType {
	case types.SQLInsertFunc, types.SQLDeleteFunc, types.SQLUpdateFunc:
		switch param.Type.Kind {
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
			reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
			returnArgs = append(returnArgs, 0, "err")
		case reflect.Bool:
			returnArgs = append(returnArgs, false, "err")
		case reflect.String:
			returnArgs = append(returnArgs, `""`, "err")
		case reflect.Float32, reflect.Float64:
			returnArgs = append(returnArgs, 0.0, "err")
		}
	case types.SQLSelectFunc:
		returnArgs = append(returnArgs, sqlExecuteResultName, "err")
	}

	return astutils.BuildIfErrNENilReturn(returnArgs...)
}

// 构建给主键赋值的语句
// lastInsertedId, err := result.LastInsertId()
//
//	if err != nil {
//	    return 0, err
//	}
//
// user.Id = lastInsertedId
func (g *FileGenerator) generatePrimaryKeyAssign(options *sqlGenOptions, decl *types.Declaration) []ast.Stmt {
	var (
		findPrimaryKey func(param *types.Param) *types.Param
		names          []string
	)
	findPrimaryKey = func(param *types.Param) *types.Param {
		if param == nil {
			return nil
		}
		if param.Type.IsSlice() {
			return nil
		}
		if param.Type.IsPointer() {
			return findPrimaryKey(&types.Param{Name: param.Name, Type: *param.Type.ValueType})
		}

		if param.Type.IsBasicType() {
			if tag := param.Type.Tag.Get("db"); tag != "" && strings.Contains(tag, entityFiledPrimaryKeyName) {
				return param
			}
		}

		names = append(names, param.Name)
		for _, field := range param.Type.Fields {
			pkType := findPrimaryKey(field)
			if pkType != nil {
				names = append(names, field.Name)
				return pkType
			}
		}

		return nil
	}

	var (
		pkParam *types.Param
	)
	inputParams := utils.Values(decl.SqlFuncDecl.InputParam)
	for i := 0; i < len(inputParams); i++ {
		pkParam = findPrimaryKey(inputParams[i])
		if pkParam != nil {
			break
		}
	}

	if pkParam == nil {
		return nil
	}

	switch pkParam.Type.Kind {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
	default:
		return nil
	}

	// 构建 lastInsertedId, err := result.LastInsertId()
	assignStmt := astutils.BuildCallAssign([]string{options.lastInsertedIdName, "err"}, ":=", options.sqlExecuteResultName[0]+"."+lastInsertIdFuncName, nil, false)
	// 构建if err != nil {return err}
	errReturnStmt := g.generateReturnErrAst(decl.SqlFuncDecl.FuncReturnResultParam, options.sqlExecuteResultName[0], decl.SqlFuncDecl.Annotation)
	// 构建主键赋值
	var idAssignStmt ast.Stmt
	if pkParam.Type.Kind == reflect.Int64 {
		idAssignStmt = astutils.BuildAssignStmt([]string{strings.Join(names, ".")}, []string{options.lastInsertedIdName})
	} else {
		idAssignStmt = astutils.BuildCallAssign([]string{strings.Join(names, ".")}, "=", pkParam.Type.Kind.String(), []*astutils.FuncArg{
			{Name: options.lastInsertedIdName},
		}, false)
	}

	return []ast.Stmt{assignStmt, errReturnStmt, astutils.BuildEmptyStmt(), idAssignStmt}
}

func (g *FileGenerator) generateRowAffectedAssignAndReturnStmt(options *sqlGenOptions, decl *types.Declaration) []ast.Stmt {
	if decl.SqlFuncDecl.Annotation == types.SQLSelectFunc || decl.SqlFuncDecl.FuncReturnResultParam == nil {
		return []ast.Stmt{astutils.BuildReturnStmt(options.sqlOperationResultName, "nil")}
	}

	assignStmt := astutils.BuildCallAssign([]string{options.rowsAffectedName, "err"}, ":=", options.sqlExecuteResultName[0]+"."+rowsAffectedFuncName, nil, false)
	errReturnStmt := g.generateReturnErrAst(decl.SqlFuncDecl.FuncReturnResultParam, options.sqlExecuteResultName[0], decl.SqlFuncDecl.Annotation)
	var returnStmt ast.Stmt
	if decl.SqlFuncDecl.FuncReturnResultParam.Type.Kind == reflect.Int64 {
		returnStmt = astutils.BuildReturnStmt(options.rowsAffectedName, "nil")
	} else {
		returnStmt = astutils.BuildReturnStmtByExpr(astutils.BuildCallExpr(ast.NewIdent(decl.SqlFuncDecl.FuncReturnResultParam.Type.Kind.String()), []ast.Expr{ast.NewIdent(options.rowsAffectedName)}, false), ast.NewIdent("nil"))
	}

	return []ast.Stmt{assignStmt, errReturnStmt, astutils.BuildEmptyStmt(), returnStmt}
}

type sqlGenOptions struct {
	*sqlutils.SqlParseResult
	execOptionName          string
	receiverName            string
	receiverDbFieldName     string
	sqlOperationName        string
	sqlOperationResultName  string
	sqlExecuteResultName    []string
	sqlExecuteArgsName      []string
	lastInsertedIdName      string
	rowsAffectedName        string
	newResultOptionArgsName []string
	selectRowsName          string
	selectObjName           string
	builderName             string
}

// 对静态sql的代码生成进行预处理
func preprocessingStaticSqlGen(decl *types.Declaration, sql string) (*sqlGenOptions, error) {
	usedNames := collection.NewSetFromSlice[string](utils.Keys(decl.SqlFuncDecl.InputParam))
	if decl.SqlFuncDecl.Receiver != nil {
		usedNames.Add(decl.SqlFuncDecl.Receiver.Name)
	}
	for _, v := range decl.SqlFuncDecl.OutputParam {
		if v.Name != "" {
			usedNames.Add(v.Name)
		}
	}

	var sqlInfo *sqlutils.SqlParseResult
	if decl.SqlFuncDecl.SqlParseResult != nil {
		sqlInfo = decl.SqlFuncDecl.SqlParseResult
		sqlInfo.SQL = sql
	}

	var (
		sqlOperationName     = dbExecOptName
		sqlExecuteResultName = []string{getAvailableName("result", usedNames), "err"}
		options              = &sqlGenOptions{
			execOptionName:         getAvailableName("option", usedNames),
			receiverName:           decl.SqlFuncDecl.Receiver.Name,
			receiverDbFieldName:    getReceiverDbFieldName(decl.SqlFuncDecl.Receiver),
			SqlParseResult:         sqlInfo,
			sqlOperationResultName: getAvailableName("res", usedNames),
			lastInsertedIdName:     getAvailableName("lasInsertedId", usedNames),
			rowsAffectedName:       getAvailableName("rowsAffected", usedNames),
			selectRowsName:         getAvailableName("rows", usedNames),
			selectObjName:          getAvailableName("obj", usedNames),
			builderName:            getAvailableName("builder", usedNames),
		}
	)

	options.sqlExecuteArgsName = append(options.sqlExecuteArgsName, options.execOptionName+"."+execOptionFieldSqlStmtName, options.execOptionName+"."+execOptionFieldArgsName)
	switch decl.SqlFuncDecl.Annotation {
	case types.SQLInsertFunc:
		options.newResultOptionArgsName = append(options.newResultOptionArgsName, corePackageName+"."+sqlTypeInsertName, nilName, errName, sqlExecuteResultName[0])
	case types.SQLDeleteFunc:
		options.newResultOptionArgsName = append(options.newResultOptionArgsName, corePackageName+"."+sqlTypeDeleteName, nilName, errName, sqlExecuteResultName[0])
	case types.SQLUpdateFunc:
		options.newResultOptionArgsName = append(options.newResultOptionArgsName, corePackageName+"."+sqlTypeUpdateName, nilName, errName, sqlExecuteResultName[0])
	case types.SQLSelectFunc:
		sqlOperationName = dbGetOptName
		if decl.SqlFuncDecl.FuncReturnResultParam == nil {
			return nil, errors.Errorf("Select statement must have two returning parameters")
		}
		if decl.SqlFuncDecl.FuncReturnResultParam.Type.IsSlice() {
			sqlOperationName = dbSelectOptName
		}
		sqlExecuteResultName = sqlExecuteResultName[1:]
		options.newResultOptionArgsName = append(options.newResultOptionArgsName, corePackageName+"."+sqlTypeSelectName, options.sqlOperationResultName, errName, nilName)
	default:
		return nil, errors.Errorf("annotation error")
	}

	options.sqlOperationName = sqlOperationName
	options.sqlExecuteResultName = sqlExecuteResultName

	return options, nil
}

// 防止函数body中出现的变量名和函数参数名称出现重复
func getAvailableName(initial string, usedNames collection.Set[string]) string {
	if !usedNames.Has(initial) {
		usedNames.Add(initial)
		return initial
	}

	initial += "x"

	return getAvailableName(initial, usedNames)
}

func getReceiverDbFieldName(param *types.Param) string {
	if param.Type.IsPointer() {
		return getReceiverDbFieldName(&types.Param{Name: param.Name, Type: *param.Type.ValueType})
	}

	for _, field := range param.Type.Fields {
		typeSpec := &field.Type
		if field.Type.IsPointer() {
			typeSpec = field.Type.ValueType
		}
		if typeSpec.Name == sqlDBName && typeSpec.Package.PackageName == sqlPackageName && typeSpec.Package.PackagePath == sqlPackagePathName {
			return field.Name
		}
	}

	return ""
}

func (g *FileGenerator) generateDynamicSqlFuncBodyAst(decl *types.Declaration, options *sqlGenOptions) (*ast.BlockStmt, error) {
	blockStmt := &ast.BlockStmt{}

	var (
		whereInitial, setInitial = g.statisticsInitialCapacity(decl.SqlFuncDecl.Sql)
		builderAssignExpr        *ast.AssignStmt
		genericsName             = ""
		genericsStar             = false
		builderVarName           = options.builderName
	)
	if stmt := g.findForeachStmt(decl.SqlFuncDecl.Sql); stmt != nil {
		param := decl.SqlFuncDecl.InputParam[stmt.CollectionName]
		if !param.Type.IsSlice() {
			return nil, errors.Errorf("param %s is not slice type", stmt.CollectionName)
		}

		valueType := &param.Type

		if valueType.IsPointer() {
			genericsStar = true
			valueType = valueType.ValueType
		}
		if valueType.Package == nil {
			genericsName = valueType.Name
		} else {
			genericsName = valueType.Package.PackageName + "." + valueType.Name
		}
	}

	var (
		dynamicSqlAstList = []ast.Stmt{}
		totalSqlLen       int
	)

	// 生成动态sql代码Ast
	for _, sql := range decl.SqlFuncDecl.Sql {
		var (
			astStmts []ast.Stmt
			sqlLen   int
		)
		switch stmt := sql.(type) {
		case *types.WhereStmt:
			astStmts, sqlLen = g.generateWhereStmtAst(stmt, builderVarName)
		case *types.SetStmt:
			astStmts, sqlLen = g.generateSetStmtAst(stmt, builderVarName)
		case *types.IfStmt:
			astStmts, sqlLen = g.generateIfStmtAst(stmt, builderVarName)
		case *types.ForeachStmt:
			astStmts, sqlLen = g.generateForeachStmtAst(stmt, builderVarName)
		case *types.SimpleStmt:
			astStmts, sqlLen = g.generateSimpleStmtAst(stmt, builderVarName)
		case *types.EmptySQLImpl: // 什么也不做
		default:
			return nil, errors.Errorf("unknown annotaion type: %T", sql)
		}
		totalSqlLen += sqlLen
		dynamicSqlAstList = append(dynamicSqlAstList, astStmts...)
	}
	builderAssignExpr = astutils.BuildCallAssignGenerics([]string{builderVarName}, ":=", corePackageName+"."+funcNameNewSqlBuilder, []*astutils.FuncArg{
		{Name: strconv.Itoa(roundUp(totalSqlLen)), BasicLitFlag: token.INT},
		{Name: strconv.Itoa(whereInitial), BasicLitFlag: token.INT},
		{Name: strconv.Itoa(setInitial), BasicLitFlag: token.INT},
	}, genericsName, genericsStar, false)
	blockStmt.List = append(blockStmt.List, builderAssignExpr)
	blockStmt.List = append(blockStmt.List, dynamicSqlAstList...)

	commonStmts, err := g.generateCommonCode(decl, options, true)
	if err != nil {
		return nil, err
	}
	blockStmt.List = append(blockStmt.List, commonStmts...)

	return blockStmt, nil
}

// 生成静态sql和动态sql公共部分
func (g *FileGenerator) generateCommonCode(decl *types.Declaration, options *sqlGenOptions, isDynamic bool) ([]ast.Stmt, error) {
	resList := make([]ast.Stmt, 0, 16)
	// 生成option.ExecOption赋值操作
	// option := &vulcan.ExecOption{
	//		SqlStmt: "SELECT ...",
	//		Args:    []any{...},
	//		Execer:  ...,
	//	}
	composite := &ast.CompositeLit{
		Type: astutils.BuildIdentOrSelectorExpr(corePackageName + "." + "ExecOption"),
	}

	if isDynamic {
		composite.Elts = []ast.Expr{
			astutils.BuildKeyValueExpr(execOptionFieldSqlStmtName, astutils.BuildSimpleCall(ast.NewIdent(options.builderName), ast.NewIdent(sqlBuilderFuncString))),
		}
	} else {
		composite.Elts = []ast.Expr{
			astutils.BuildKeyValueBasicLitExpr(execOptionFieldSqlStmtName, fmt.Sprintf("%q", options.SQL), token.STRING),
		}
	}

	if isDynamic {
		composite.Elts = append(composite.Elts, astutils.BuildKeyValueExpr(execOptionFieldArgsName, astutils.BuildSimpleCall(ast.NewIdent(options.builderName), ast.NewIdent(sqlBuilderFuncArgs))))
	} else {
		// 如果sql参数不为空, 则添加参数
		if len(options.ParamsName) > 0 {
			composite.Elts = append(composite.Elts, astutils.BuildKeyValueExpr(execOptionFieldArgsName, &ast.CompositeLit{
				Type: &ast.ArrayType{
					Elt: ast.NewIdent("any"),
				},
				Elts: stream.Map(options.ParamsName, func(name string) ast.Expr {
					return astutils.BuildIdentOrSelectorExpr(name)
				}),
			}))
		}
	}
	composite.Elts = append(composite.Elts, astutils.BuildKeyValueExpr(execOptionFieldExecerName, astutils.BuildIdentOrSelectorExpr(options.receiverName+"."+options.receiverDbFieldName)))

	// 如果有扩展字段则需要传入ExecOption
	for _, param := range decl.SqlFuncDecl.InputParam {
		if types.IsRegisteredExtension(param) {
			composite.Elts = append(composite.Elts, astutils.BuildKeyValueBasicLitExpr(execOptionFieldExtensionName, param.Name, token.STRING))
		}
	}

	optionAssign := &ast.AssignStmt{
		Lhs: []ast.Expr{ast.NewIdent(options.execOptionName)},
		Rhs: []ast.Expr{astutils.BuildUnaryExpr("&", composite)},
		Tok: token.DEFINE,
	}
	resList = append(resList, optionAssign)

	// 构建拦截器preHandle调用语句
	// vulcan.InvokePreHandler(option, opts...)
	preInterceptorCall := astutils.BuildSimpleCallAssign(corePackageName+"."+invokePreHandlerName, []*astutils.FuncArg{
		{Name: options.execOptionName},
		{Name: g.optsName},
	}, true)
	resList = append(resList, &ast.ExprStmt{X: preInterceptorCall})

	// 如果是select语句, 则需要new一个对象
	// res := &pkg.Struct{}
	if decl.SqlFuncDecl.Annotation == types.SQLSelectFunc {
		assignStmt := astutils.BuildInitAssignExpr(decl.SqlFuncDecl.FuncReturnResultParam, options.sqlOperationResultName, decl.PkgInfo.PackageName)
		resList = append(resList, assignStmt)
	}

	var (
		queryStmt      ast.Stmt
		selectScanFunc func() []ast.Stmt
	)
	// 构建数据库操作语句
	if decl.SqlFuncDecl.Annotation == types.SQLSelectFunc {
		returnType := &decl.SqlFuncDecl.FuncReturnResultParam.Type
		if returnType.IsSlice() {
			// 处理批量查询
			// rows, err := option.Select(option.SqlStmt, option.Args...)
			queryStmt, selectScanFunc = g.generateDBSelectStmt(decl, options)
		} else {
			// 处理单条记录的查询
			// err := option.Get(option.SqlStmt, option.Args...).Scan(&res.Id, ...)
			queryStmt = g.generateDBGetStmt(decl, options)
		}
		resList = append(resList, queryStmt)
	} else {
		// 处理sql执行语句
		// result, err := option.Exec(option.SqlStmt, option.Args...)
		execArgs := make([]*astutils.FuncArg, 0, 3)
		execArgs = append(execArgs, stream.Map(options.sqlExecuteArgsName, func(v string) *astutils.FuncArg {
			return &astutils.FuncArg{Name: v}
		})...)
		dbCallExpr := astutils.BuildDefineStmtByExpr(astutils.BuildIdentList(options.sqlExecuteResultName...),
			[]ast.Expr{astutils.BuildSimpleCallAssign(options.execOptionName+"."+options.sqlOperationName, execArgs, true)})
		resList = append(resList, dbCallExpr)
	}

	// 构建拦截器postHandle调用语句
	// vulcan.InvokePostHandler(vulcan.NewResultOption(vulcan.SQLTypeUpdate, nil, err, result))
	postInterceptorCall := astutils.BuildCallExpr(astutils.BuildIdentOrSelectorExpr(corePackageName+"."+invokePostHandlerName), []ast.Expr{
		astutils.BuildSimpleCallAssign(corePackageName+"."+newResultOptionName, stream.Map(options.newResultOptionArgsName, func(v string) *astutils.FuncArg {
			return &astutils.FuncArg{Name: v}
		}), false),
	}, false)
	resList = append(resList, &ast.ExprStmt{X: postInterceptorCall})

	// 构建err判断语句
	// if err != nil {
	//		return err
	//	}
	resList = append(resList, g.generateReturnErrAst(decl.SqlFuncDecl.FuncReturnResultParam, options.sqlOperationResultName, decl.SqlFuncDecl.Annotation))

	// 如果是查询列表, 则需要生成for循环Scan语句
	// defer rows.Close()
	//	for rows.Next() {
	//		obj := &model.User{}
	//		rows.Scan(&obj.Id, ...)
	//		res = append(res, obj)
	//	}
	if selectScanFunc != nil {
		resList = append(resList, selectScanFunc()...)
	}

	// 如果是插入语句, 可能需要给自增Id赋值
	// id, err := result.LastInsertId()
	//	if err != nil {
	//		return 0, err
	//	}
	//	user.Id = id
	if decl.SqlFuncDecl.Annotation == types.SQLInsertFunc {
		stmts := g.generatePrimaryKeyAssign(options, decl)
		if len(stmts) > 0 {
			// 添加空行
			resList = append(resList, astutils.BuildEmptyStmt())
			resList = append(resList, stmts...)
		}
	}

	if decl.SqlFuncDecl.FuncReturnResultParam != nil {
		// 如果是增删改语句, 可能需要返回rowAffected
		// affected, err := result.RowsAffected()
		//	if err != nil {
		//		return 0, err
		//	}
		// return int(affected), nil
		rowsAffectedStmt := g.generateRowAffectedAssignAndReturnStmt(options, decl)
		resList = append(resList, astutils.BuildEmptyStmt())
		resList = append(resList, rowsAffectedStmt...)
	} else {
		// 直接构建返回语句
		// return nil
		resList = append(resList, astutils.BuildEmptyStmt())
		resList = append(resList, astutils.BuildReturnStmt("nil"))
	}

	return resList, nil
}

func (g *FileGenerator) generateWhereStmtAst(stmt *types.WhereStmt, builderVarName string) (astStmts []ast.Stmt, sqlLen int) {
	switch cond := stmt.Cond.(type) {
	case *types.IfStmt:
		return g.generateIfStmtAstHelper([]*types.IfStmt{cond}, builderVarName, sqlBuilderFuncAppendWhereStmtConditional, sqlBuilderFuncEndWhereStmt)
	case *types.IfChainStmt:
		return g.generateIfStmtAstHelper(cond.Stmts, builderVarName, sqlBuilderFuncAppendWhereStmtConditional, sqlBuilderFuncEndWhereStmt)
	case *types.ChooseStmt:
		return g.generateChooseStmtAstHelper(cond.Whens, cond.Otherwise, cond.OtherwiseArgs, builderVarName, sqlBuilderFuncAppendAppendWhereStmtChoosed)
	}
	return
}

func (g *FileGenerator) generateIfStmtAstHelper(stmts []*types.IfStmt, builderVarName, appendFuncName, endFuncName string) (astStmts []ast.Stmt, sqlLen int) {
	var (
		x     ast.Expr = ast.NewIdent(builderVarName)
		inner *ast.CallExpr
	)
	for i := 0; i < len(stmts); i++ {
		stmt := stmts[i]
		sqlLen += len(stmt.Sql)
		inner = &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   x,
				Sel: ast.NewIdent(appendFuncName),
			},
			Args: []ast.Expr{
				stmt.CondExpr,
			},
		}

		inner.Args = append(inner.Args, astutils.BuildBasicLit(token.STRING, fmt.Sprintf("%q", stmt.Sql)))
		inner.Args = append(inner.Args, astutils.BuildIdentOrSelectorExprList(stmt.Args)...)
		x = inner
	}
	astStmts = []ast.Stmt{&ast.ExprStmt{X: astutils.BuildSimpleCall(x, ast.NewIdent(endFuncName))}}
	return
}

func (g *FileGenerator) generateChooseStmtAstHelper(whens []*types.WhenStmt, otherwise string, otherwiseArgs []string, builderVarName, appendFuncName string) (astStmts []ast.Stmt, sqlLen int) {
	condSqls := make([]ast.Expr, 0, len(whens))
	sqlLen = len(otherwise)
	for _, when := range whens {
		sqlLen = max(sqlLen, len(when.Sql))
		callArgs := []ast.Expr{
			when.CondExpr,
			astutils.BuildBasicLit(token.STRING, fmt.Sprintf("%q", when.Sql)),
		}
		condSqls = append(condSqls, astutils.BuildCallExpr(astutils.BuildIdentOrSelectorExpr(corePackageName+"."+funcNameNewConditionSql), callArgs, false))
		callArgs = append(callArgs, astutils.BuildIdentOrSelectorExprList(when.Args)...)
	}
	arg1 := astutils.BuildCallExpr(astutils.BuildIdentOrSelectorExpr(corePackageName+"."+funcNameMakeSlice), condSqls, false)
	arg2 := astutils.BuildBasicLit(token.STRING, fmt.Sprintf("%q", otherwise))
	args := []ast.Expr{arg1, arg2}
	if len(otherwiseArgs) == 0 {
		args = append(args, ast.NewIdent("nil"))
	} else {
		args = append(args, astutils.BuildIdentOrSelectorExprList(otherwiseArgs)...)
	}

	astStmts = []ast.Stmt{
		&ast.ExprStmt{
			X: astutils.BuildCallExpr(astutils.BuildIdentOrSelectorExpr(builderVarName+"."+appendFuncName), args, false),
		},
	}

	return
}

func (g *FileGenerator) generateSetStmtAst(stmt *types.SetStmt, builderVarName string) (astStmts []ast.Stmt, sqlLen int) {
	switch cond := stmt.Cond.(type) {
	case *types.IfStmt:
		return g.generateIfStmtAstHelper([]*types.IfStmt{cond}, builderVarName, sqlBuilderFuncAppendSetStmtConditional, sqlBuilderFuncEndSetStmt)
	case *types.IfChainStmt:
		return g.generateIfStmtAstHelper(cond.Stmts, builderVarName, sqlBuilderFuncAppendSetStmtConditional, sqlBuilderFuncEndSetStmt)
	case *types.ChooseStmt:
		return g.generateChooseStmtAstHelper(cond.Whens, cond.Otherwise, cond.OtherwiseArgs, builderVarName, sqlBuilderFuncAppendSetStmtChoosed)
	}
	return
}

func (g *FileGenerator) generateIfStmtAst(stmt *types.IfStmt, builderVarName string) (astStmts []ast.Stmt, sqlLen int) {
	funcArgs := []ast.Expr{
		stmt.CondExpr,
		astutils.BuildBasicLit(token.STRING, fmt.Sprintf("%q", stmt.Sql)),
	}
	funcArgs = append(funcArgs, astutils.BuildIdentOrSelectorExprList(stmt.Args)...)
	astStmts = append(astStmts, &ast.ExprStmt{
		X: astutils.BuildCallExpr(astutils.BuildIdentOrSelectorExpr(builderVarName+"."+sqlBuilderFuncAppendStmtConditional), funcArgs, false),
	})
	sqlLen = len(stmt.Sql)
	return
	return
}

func (g *FileGenerator) generateForeachStmtAst(stmt *types.ForeachStmt, builderVarName string) (astStmts []ast.Stmt, sqlLen int) {
	funcArgs := make([]ast.Expr, 0, 6)
	funcArgs = append(funcArgs, ast.NewIdent(builderVarName))
	funcArgs = append(funcArgs, ast.NewIdent(stmt.CollectionName))
	funcArgs = append(funcArgs, astutils.BuildBasicLit(token.STRING, fmt.Sprintf("%q", stmt.Separator)))
	funcArgs = append(funcArgs, astutils.BuildBasicLit(token.STRING, fmt.Sprintf("%q", stmt.Open)))
	funcArgs = append(funcArgs, astutils.BuildBasicLit(token.STRING, fmt.Sprintf("%q", stmt.Close)))
	var typeExpr ast.Expr
	if strings.HasSuffix(stmt.ItemType, "*") {
		itemType := strings.TrimLeft(stmt.ItemType, "*")
		typeExpr = &ast.StarExpr{
			X: astutils.BuildIdentOrSelectorExpr(itemType),
		}
	} else {
		typeExpr = astutils.BuildIdentOrSelectorExpr(stmt.ItemType)
	}
	returnStmt := &ast.ReturnStmt{
		Results: []ast.Expr{
			&ast.CompositeLit{
				Type: &ast.ArrayType{
					Elt: ast.NewIdent("any"),
				},
				Elts: astutils.BuildIdentOrSelectorExprList(stmt.Args),
			},
		},
	}
	funcArgs = append(funcArgs, &ast.FuncLit{
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							ast.NewIdent(stmt.ItemName),
						},
						Type: typeExpr,
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.ArrayType{
							Elt: ast.NewIdent("any"),
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				returnStmt,
			},
		},
	})
	funcArgs = append(funcArgs, astutils.BuildBasicLit(token.STRING, fmt.Sprintf("%q", stmt.Sql)))
	astStmts = []ast.Stmt{&ast.ExprStmt{X: astutils.BuildCallExpr(astutils.BuildIdentOrSelectorExpr(corePackageName+"."+sqlBuilderFuncAppendLoopStmt), funcArgs, false)}}
	return
}

func (g *FileGenerator) generateSimpleStmtAst(stmt *types.SimpleStmt, builderVarName string) (astStmts []ast.Stmt, sqlLen int) {
	funcArgs := []ast.Expr{astutils.BuildBasicLit(token.STRING, fmt.Sprintf("%q", stmt.Sql))}
	funcArgs = append(funcArgs, astutils.BuildIdentOrSelectorExprList(stmt.Args)...)
	astStmts = append(astStmts, &ast.ExprStmt{
		X: astutils.BuildCallExpr(astutils.BuildIdentOrSelectorExpr(builderVarName+"."+sqlBuilderFuncAppendStmt), funcArgs, false),
	})
	sqlLen = len(stmt.Sql)
	return
}

func (g *FileGenerator) findForeachStmt(sqls []types.SQL) *types.ForeachStmt {
	for _, sql := range sqls {
		if stmt, ok := sql.(*types.ForeachStmt); ok {
			return stmt
		}
	}

	return nil
}

func (g *FileGenerator) statisticsInitialCapacity(sqls []types.SQL) (int, int) {
	var (
		whereInitial, setInitial int
	)

	for _, sql := range sqls {
		switch stmt := sql.(type) {
		case *types.WhereStmt:
			switch ifChainStmt := stmt.Cond.(type) {
			case *types.IfStmt:
				whereInitial++
			case *types.IfChainStmt:
				whereInitial += len(ifChainStmt.Stmts)
			}
		case *types.SetStmt:
			switch ifChainStmt := stmt.Cond.(type) {
			case *types.IfStmt:
				setInitial++
			case *types.IfChainStmt:
				setInitial += len(ifChainStmt.Stmts)
			}
		}
	}

	return whereInitial, setInitial
}

func (g *FileGenerator) getOptsName(optsName string, inputParm map[string]*types.Param) string {
	for _, v := range inputParm {
		if v.Name == optsName {
			optsName += "1"
			optsName = g.getOptsName(optsName, inputParm)
			break
		}
	}

	return optsName
}

func (g *FileGenerator) generateCode(filename string) error {
	astFile := &ast.File{
		Name:     g.srcFile.AstFile.Name,
		Imports:  g.srcFile.PkgInfo.AstImports,
		Doc:      g.srcFile.AstFile.Doc,
		Comments: g.srcFile.AstFile.Comments,
	}
	importGenDecl := &ast.GenDecl{
		Tok: token.IMPORT,
	}
	set := collection.NewSet[string]()
	for _, importSpec := range g.srcFile.PkgInfo.AstImports {
		if !set.Has(importSpec.Path.Value) {
			importGenDecl.Specs = append(importGenDecl.Specs, importSpec)
			set.Add(importSpec.Path.Value)
		}
	}
	astFile.Decls = append(astFile.Decls, importGenDecl)

	tempName := strutil.RandString(8) + strconv.Itoa(int(time.Now().UnixNano()))
	astFile.Decls = append(astFile.Decls, stream.Map(g.srcFile.Declarations, func(t types.Declaration) ast.Decl {
		// 处理结构体单字段生成不会换行的问题
		genDecl, ok := t.AstDecl.(*ast.GenDecl)
		if !ok {
			return t.AstDecl
		}

		stream.ForEach(genDecl.Specs, func(spec ast.Spec) bool {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				return true
			}
			if typeSpec.Type == nil {
				return true
			}

			st, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				return true
			}

			if st.Fields == nil || len(st.Fields.List) != 1 {
				return true
			}

			st.Fields.List = append(st.Fields.List, &ast.Field{
				Names: []*ast.Ident{ast.NewIdent("_")},
				Type:  ast.NewIdent(tempName),
			})

			return true
		})

		return t.AstDecl
	})...)

	srcBuf := bytes.NewBuffer(nil)
	srcBuf.Grow(8 << 10)
	// 写入doc
	if astFile.Doc != nil && len(astFile.Doc.List) > 0 {
		for _, doc := range astFile.Doc.List {
			srcBuf.WriteString(doc.Text)
			srcBuf.WriteString("\n")
		}
	}

	// 写入package
	srcBuf.WriteString("package " + astFile.Name.Name + "\n\n")
	tempFst := token.NewFileSet()
	for _, d := range astFile.Decls {
		buf := bytes.NewBuffer(nil)
		buf.Grow(1024)
		// 处理注释
		var commentGroup *ast.CommentGroup
		switch decl := d.(type) {
		case *ast.FuncDecl:
			commentGroup = decl.Doc
			decl.Doc = nil
		case *ast.GenDecl:
			commentGroup = decl.Doc
			decl.Doc = nil
		}

		if commentGroup != nil && len(commentGroup.List) >= 0 {
			for _, comment := range commentGroup.List {
				buf.WriteString(comment.Text)
				buf.WriteString("\n")
			}
		}

		if err := format.Node(buf, tempFst, d); err != nil {
			return err
		}
		srcBuf.WriteString(g.formatFuncSource(buf.String()))
		srcBuf.WriteString("\n\n")
	}

	source := srcBuf.String()
	// 替换空行
	source = trimEmptyLineSign(source)

	// 在所有类型声明和函数声明前面加一个空行
	//r := strings.NewReplacer([]string{
	//	"\nfunc", "\n\nfunc",
	//	"\ntype ", "\ntype ",
	//}...)
	//source = r.Replace(source)
	//// 控制声明块之间只有一个空行
	//source = strings.ReplaceAll(source, "\n\n\n", "\n\n")

	// 所有的结构体初始化, key:val添加换行
	const startKey = "vulcan.ExecOption{SqlStmt"
	const endKey = "}\n"
	replacer := strings.NewReplacer([]string{
		startKey, "vulcan.ExecOption{\n\t\tSqlStmt",
		", Execer:", ",\n\t\tExecer:",
		", Args:", ",\n\t\tArgs:",
		", Extension:", ",\n\t\tExtension:",
		endKey, ",\n\t}\n",
	}...)
	for {
		idx1 := strings.Index(source, startKey)
		if idx1 == -1 {
			break
		}
		idx2 := strings.Index(source[idx1:], endKey)
		fragment := source[idx1 : idx1+idx2+len(endKey)]
		fragment = replacer.Replace(fragment)
		source = source[:idx1] + fragment + source[idx1+idx2+len(endKey):]
	}

	// 处理占位结构体字段
	for {
		idx1 := strings.Index(source, tempName)
		if idx1 == -1 {
			break
		}
		idx2 := strings.LastIndex(source[:idx1], "\n")

		source = source[:idx2] + source[idx1+len(tempName):]
	}

	file, err := os.OpenFile(filename, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0644)
	if err != nil {
		return errors.Errorf("open file %s error: %v", filename, err)
	}
	defer file.Close()

	fmt.Fprint(file, fileHeaderComment)
	fmt.Fprint(file, source)

	log.Infof("Generate go file %s!", filename)
	return nil
}

func (g *FileGenerator) formatFuncSource(source string) string {
	replacer := strings.NewReplacer(
		").AppendWhereStmtConditional", ").\n\t\tAppendWhereStmtConditional",
		").AppendSetStmtConditional", ").\n\t\tAppendSetStmtConditional",
		"vulcan.NewConditionSql", "\n\t\tvulcan.NewConditionSql",
	)
	return replacer.Replace(source)
}

func (g *FileGenerator) generateDBSelectStmt(decl *types.Declaration, options *sqlGenOptions) (ast.Stmt, func() []ast.Stmt) {
	// 构建Select查询语句
	selectStmt := astutils.BuildCallAssign([]string{options.selectRowsName, "err"}, ":=", options.execOptionName+"."+dbSelectOptName, []*astutils.FuncArg{
		{
			Name: options.execOptionName + "." + execOptionFieldSqlStmtName,
		},
		{
			Name: options.execOptionName + "." + execOptionFieldArgsName,
		},
	}, true)

	return selectStmt, func() []ast.Stmt {
		// 构建defer语句
		deferStmt := &ast.DeferStmt{
			Call: &ast.CallExpr{
				Fun: astutils.BuildSelectorExpr([]string{options.selectRowsName, dbRowsCloseName}),
			},
		}
		// 构建for循环
		forStmt := &ast.ForStmt{
			Cond: &ast.CallExpr{
				Fun: astutils.BuildSelectorExpr([]string{options.selectRowsName, dbRowsNextName}),
			},
			Body: &ast.BlockStmt{},
		}
		valueType := decl.SqlFuncDecl.FuncReturnResultParam.Type.ValueType
		param := &types.Param{Type: *valueType}
		// 构建对象声明语句
		initAssignExpr := astutils.BuildInitAssignExpr(param, options.selectObjName, decl.PkgInfo.PackageName)
		// 构建Scan语句
		var scanFuncArgs []*astutils.FuncArg
		if decl.SqlFuncDecl.FuncReturnResultParam.Type.GetValueType().IsBasicType() {
			scanFuncArgs = []*astutils.FuncArg{{Name: options.selectObjName, AndFlag: true}}
		} else {
			scanFuncArgs = stream.Map(decl.SqlFuncDecl.SelectFields, func(name string) *astutils.FuncArg {
				return &astutils.FuncArg{Name: options.selectObjName + "." + name, AndFlag: true}
			})
		}
		scanCallExpr := astutils.BuildCallAssign([]string{"err"}, "=", options.selectRowsName+"."+dbScanOptName, scanFuncArgs, false)
		// 构建if err != nil 判断
		errReturnStmt := g.generateReturnErrAst(decl.SqlFuncDecl.FuncReturnResultParam, options.sqlOperationResultName, decl.SqlFuncDecl.Annotation)
		// 构建append语句
		appendStmt := astutils.BuildCallAssign([]string{options.sqlOperationResultName}, "=", "append", []*astutils.FuncArg{
			{Name: options.sqlOperationResultName},
			{Name: options.selectObjName},
		}, false)
		forStmt.Body.List = []ast.Stmt{initAssignExpr, scanCallExpr, errReturnStmt, appendStmt}

		return []ast.Stmt{deferStmt, forStmt}
	}
}

func (g *FileGenerator) generateDBGetStmt(decl *types.Declaration, options *sqlGenOptions) ast.Stmt {
	// 构建option.Get(arg1, arg2).Scan(arg3, arg4, ...)语句
	// 先构建option.Get()
	getExpr := astutils.BuildCallExpr(astutils.BuildSelectorExpr([]string{options.execOptionName, dbGetOptName}), []ast.Expr{
		astutils.BuildSelectorExpr([]string{options.execOptionName, execOptionFieldSqlStmtName}),
		astutils.BuildSelectorExpr([]string{options.execOptionName, execOptionFieldArgsName}),
	}, true)

	var scanArgsExpr []ast.Expr
	if decl.SqlFuncDecl.FuncReturnResultParam.Type.GetValueType().IsBasicType() {
		scanArgsExpr = []ast.Expr{astutils.BuildUnaryExpr("&", ast.NewIdent(options.sqlOperationResultName))}
	} else {
		scanArgsExpr = stream.Map(decl.SqlFuncDecl.SelectFields, func(name string) ast.Expr {
			return astutils.BuildUnaryExpr("&", astutils.BuildSelectorExpr([]string{options.sqlOperationResultName, name}))
		})
	}
	// 构建.Scan()
	scanExpr := &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   getExpr,
			Sel: ast.NewIdent(dbScanOptName),
		},
		Args: scanArgsExpr,
	}
	callAssignStmt := astutils.BuildDefineStmtByExpr([]ast.Expr{ast.NewIdent("err")}, []ast.Expr{scanExpr})
	return callAssignStmt
}

func trimEmptyLineSign(source string) string {
	return strings.ReplaceAll(source, astutils.EmptyLineSign, "")
}

func roundUp(n int) int {
	if n <= 0 {
		return 1
	}
	return 1 << bits.Len(uint(n-1))
}
